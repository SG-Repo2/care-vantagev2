This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-03T17:48:33.865Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
components/
  SignInButton.tsx
context/
  AppContext.tsx
  AuthContext.tsx
  UserContext.tsx
core/
  constants/
    metrics.ts
  types/
    api.ts
    base.ts
  utils/
    formatting.ts
    scoring.ts
db/
  migrations/
    01_update_users_rls.sql
features/
  auth/
    components/
      LoginScreen.tsx
      RegisterScreen.tsx
    types/
      auth.ts
  health/
    hooks/
      useHealthData.ts
    services/
      platforms/
        AppleHealthService.ts
        GHealthConnectService.ts
        GoogleHealthService.ts
        MockHealthService.ts
      base.ts
      factory.ts
      NativeHealthConnect.ts
      platform.ts
      types.ts
    types/
      health.ts
  home/
    components/
      GoalCelebration.tsx
      HomeScreen.tsx
      MetricCard.tsx
      MetricModal.tsx
    styles/
      GoalCelebration.styles.ts
      HomeScreen.styles.ts
  leaderboard/
    components/
      LeaderboardScreen.tsx
    data/
      mockData.ts
    styles/
      LeaderboardScreen.styles.ts
    types/
      leaderboard.ts
  profile/
    components/
      ProfileScreen.tsx
    types/
      profile.ts
navigation/
  AppStack.tsx
  AuthStack.tsx
  RootNavigator.tsx
  TabNavigator.tsx
  types.ts
services/
  authService.ts
  healthMetricsService.ts
  profileService.ts
  storageService.ts
theme/
  index.ts
utils/
  supabase.ts

================================================================
Repository Files
================================================================

================
File: components/SignInButton.tsx
================
import React from 'react';
import { TouchableOpacity, Text, View } from 'react-native';
import { useAuth } from '../context/AuthContext';

export function SignInButton() {
  const { signInWithGoogle, isLoading } = useAuth();

  return (
    <TouchableOpacity 
      onPress={signInWithGoogle}
      disabled={isLoading}
      style={{
        backgroundColor: '#4285F4',
        padding: 16,
        borderRadius: 8,
      }}
    >
      <Text style={{ color: 'white', textAlign: 'center' }}>
        {isLoading ? 'Signing in...' : 'Sign in with Google'}
      </Text>
    </TouchableOpacity>
  );
}

================
File: context/AppContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useColorScheme } from 'react-native';
import { customLightTheme, customDarkTheme, AppTheme } from '../theme';

interface AppContextType {
  theme: AppTheme;
  isDarkMode: boolean;
  isLoading: boolean;
};

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const colorScheme = useColorScheme();
  const [isDarkMode, setIsDarkMode] = useState(colorScheme === 'dark');
  const [theme, setTheme] = useState(isDarkMode ? customDarkTheme : customLightTheme);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeApp = async () => {
      // Defer initialization to next frame to avoid blocking UI
      requestAnimationFrame(async () => {
        try {
          const savedTheme = await AsyncStorage.getItem('theme');
          if (savedTheme) {
            // Ensure state updates happen in next frame
            requestAnimationFrame(() => {
              setIsDarkMode(savedTheme === 'dark');
              setTheme(savedTheme === 'dark' ? customDarkTheme : customLightTheme);
            });
          }
        } catch (error) {
          console.error('Error loading theme:', error);
        } finally {
          setIsLoading(false);
        }
      });
    };

    initializeApp();
  }, []);

  useEffect(() => {
    setTheme(isDarkMode ? customDarkTheme : customLightTheme);
  }, [isDarkMode]);

  const toggleTheme = async () => {
    const newIsDarkMode = !isDarkMode;
    setIsDarkMode(newIsDarkMode);
    setTheme(newIsDarkMode ? customDarkTheme : customLightTheme);
    
    // Defer storage operation to next frame
    requestAnimationFrame(async () => {
      try {
        await AsyncStorage.setItem('theme', newIsDarkMode ? 'dark' : 'light');
      } catch (error) {
        console.error('Error saving theme:', error);
      }
    });
  };

  return (
    <AppContext.Provider value={{ theme, isDarkMode, isLoading }}>
      {children}
    </AppContext.Provider>
  );
};

export const useApp = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

================
File: context/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { supabase } from '../utils/supabase';
import * as Google from 'expo-auth-session/providers/google';
import * as WebBrowser from 'expo-web-browser';
import * as AuthSession from 'expo-auth-session';
import { Platform } from 'react-native';
import { User, mapSupabaseUser } from '../features/auth/types/auth';
import Constants from 'expo-constants';
import { profileService } from '../services/profileService';

WebBrowser.maybeCompleteAuthSession();

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  signInWithGoogle: () => Promise<void>;
  signOut: () => Promise<void>;
}

interface AuthProviderProps {
  children: ReactNode;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const googleAuth = Constants.expoConfig?.extra?.googleAuth;
  
  if (!googleAuth?.iosClientId || !googleAuth?.webClientId || !googleAuth?.androidClientId) {
    throw new Error('Missing Google Auth configuration. Check your app.config.js and .env files.');
  }

  console.log('Auth Configuration:', {
    androidClientId: googleAuth.androidClientId,
    iosClientId: googleAuth.iosClientId,
    webClientId: googleAuth.webClientId,
    clientId: googleAuth.expoClientId,
  });

  const [request, response, promptAsync] = Google.useIdTokenAuthRequest({
    clientId: Platform.select({
      ios: googleAuth.iosClientId,
      android: googleAuth.androidClientId,
      default: googleAuth.webClientId,
    }),
    iosClientId: googleAuth.iosClientId,
    androidClientId: googleAuth.androidClientId,
    webClientId: googleAuth.webClientId,
    scopes: [
      'https://www.googleapis.com/auth/userinfo.email',
      'https://www.googleapis.com/auth/userinfo.profile',
      'openid'
    ]
  });

  useEffect(() => {
    const initAuth = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        setUser(user ? mapSupabaseUser(user) : null);
      } catch (err) {
        console.error('Error initializing auth:', err);
        setError('Failed to initialize authentication');
      } finally {
        setIsLoading(false);
      }
    };

    initAuth();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (session?.user) {
        setUser(mapSupabaseUser(session.user));
      } else {
        setUser(null);
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  useEffect(() => {
    if (response?.type === 'success') {
      const { id_token } = response.params;
      handleGoogleSignIn(id_token);
    } else if (response?.type === 'error') {
      console.error('Google Auth Error:', response.error);
      setError(response.error?.message || 'Failed to authenticate with Google');
    }
  }, [response]);

  const handleGoogleSignIn = async (idToken: string) => {
    try {
      setError(null);
      setIsLoading(true);
      
      console.log('Attempting to sign in with token:', idToken);
      
      const { data, error } = await supabase.auth.signInWithIdToken({
        provider: 'google',
        token: idToken,
      });

      if (error) {
        console.error('Supabase auth error:', error);
        throw error;
      }
      
      if (data.user) {
        console.log('Successfully signed in user:', data.user.id);
        const mappedUser = mapSupabaseUser(data.user);
        
        // Check if profile exists
        const existingProfile = await profileService.getProfile(data.user.id);
        
        if (!existingProfile) {
          // Profile doesn't exist, create a new one
          console.log('Creating new profile for user:', data.user.id);
          try {
            await profileService.createProfile(mappedUser);
          } catch (profileError) {
            console.error('Failed to create user profile:', profileError);
            // Even if profile creation fails, we still want to set the user
            // They can try updating their profile later
          }
        }
        
        setUser(mappedUser);
      }
    } catch (err) {
      console.error('Error signing in with Google:', err);
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('Failed to sign in with Google');
      }
    } finally {
      setIsLoading(false);
    }
  };

  const signInWithGoogle = async () => {
    try {
      setError(null);
      if (!request) {
        throw new Error('Google Auth request was not initialized');
      }
      const result = await promptAsync();
      console.log('Prompt result:', result);
    } catch (err) {
      console.error('Error initiating Google sign-in:', err);
      setError('Failed to initiate Google sign-in');
    }
  };

  const signOut = async () => {
    try {
      setError(null);
      setIsLoading(true);
      await supabase.auth.signOut();
      setUser(null);
    } catch (err) {
      console.error('Error signing out:', err);
      setError('Failed to sign out');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        error,
        signInWithGoogle,
        signOut,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: context/UserContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { User } from '../services/authService';
import { StorageService } from '../services/storageService';

interface UserContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  isLoading: boolean;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadUser = async () => {
      try {
        const userData = await StorageService.getUserData();
        if (userData) {
          setUser(userData);
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadUser();
  }, []);

  const updateUser = async (newUser: User | null) => {
    setUser(newUser);
    if (newUser) {
      await StorageService.setUserData(newUser);
    } else {
      await StorageService.clearAll();
    }
  };

  return (
    <UserContext.Provider
      value={{
        user,
        setUser: updateUser,
        isLoading,
      }}
    >
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}

================
File: core/constants/metrics.ts
================
export const HEALTH_METRICS = {
  STEPS: {
    DAILY_GOAL: 10000,
    MIN_HEALTHY: 5000,
    HISTORY_DAYS: 7,  // Number of days to track in history
    START_OF_WEEK: 6  // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  },
  DISTANCE: {
    DAILY_GOAL: 8.05, // kilometers (approximately 5 miles)
    MIN_HEALTHY: 4.0, // kilometers
    HISTORY_DAYS: 7,
    START_OF_WEEK: 6
  }
};

// Helper function to get the date 6 days ago
export const getCurrentWeekStart = (): Date => {
  const today = new Date();
  const startDate = new Date(today);
  startDate.setDate(today.getDate() - 6);
  startDate.setHours(0, 0, 0, 0);
  return startDate;
};

================
File: core/types/api.ts
================
export interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
  timestamp?: Date;
}

export interface PaginatedResponse<T> extends ApiResponse<T> {
  page: number;
  limit: number;
  total: number;
  hasMore: boolean;
}

================
File: core/types/base.ts
================
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export type Gender = 'male' | 'female' | 'other' | 'prefer-not-to-say';
export type BloodType = 'A+' | 'A-' | 'B+' | 'B-' | 'AB+' | 'AB-' | 'O+' | 'O-';
export type MeasurementSystem = 'metric' | 'imperial';
export type PrivacyLevel = 'private' | 'friends' | 'public';
export type DataSource = 'apple_health' | 'health_connect' | 'manual';
export type SleepQuality = 'poor' | 'fair' | 'good' | 'excellent';

================
File: core/utils/formatting.ts
================
import { MeasurementSystem } from '../types/base';

export const formatDistance = (kilometers: number, system: MeasurementSystem): string => {
  if (system === 'imperial') {
    const miles = kilometers * 0.621371;
    return `${miles.toFixed(2)} mi`;
  }
  return `${kilometers.toFixed(2)} km`;
};

export const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return `${hours}h ${remainingMinutes}m`;
};

export const formatHeartRate = (bpm: number): string => {
  return `${Math.round(bpm)} bpm`;
};

export const formatBloodPressure = (systolic: number, diastolic: number): string => {
  return `${systolic}/${diastolic} mmHg`;
};

export const formatScore = (score: number): string => {
  return `${Math.round(score)}/100`;
};

================
File: core/utils/scoring.ts
================
import { HealthMetrics, HealthScore } from '../../features/health/types/health';
import { HEALTH_METRICS } from '../constants/metrics';

export class HealthScoring {
  static calculateScore(metrics: HealthMetrics): HealthScore {
    const steps = metrics.steps || 0;
    const distance = metrics.distance || 0;
    
    const stepsScore = this.calculateStepsScore(steps);
    const distanceScore = this.calculateDistanceScore(distance);
    const bonusPoints = this.calculateStepsBonusPoints(steps);
    
    // Combine scores and include bonus points
    const overall = Math.min(100, ((stepsScore + distanceScore) / 2) + bonusPoints);

    return {
      overall: Math.round(overall),
      categories: {
        steps: Math.round(stepsScore),
        distance: Math.round(distanceScore)
      },
      dailyVictory: steps >= HEALTH_METRICS.STEPS.DAILY_GOAL,
      bonusPoints: bonusPoints
    };
  }

  private static calculateStepsScore(steps: number): number {
    // Calculate points based on 10 points per 1000 steps
    const pointsPer1000Steps = 10;
    const basePoints = Math.floor(steps / 1000) * pointsPer1000Steps;
    
    // Cap the base points at 100
    return Math.min(100, basePoints);
  }

  private static calculateStepsBonusPoints(steps: number): number {
    // Award 5 bonus points if daily goal is reached
    const { DAILY_GOAL } = HEALTH_METRICS.STEPS;
    return steps >= DAILY_GOAL ? 5 : 0;
  }

  private static calculateDistanceScore(distance: number): number {
    const { DAILY_GOAL } = HEALTH_METRICS.DISTANCE;
    const distanceInKm = distance;
    if (distanceInKm >= DAILY_GOAL) return 100;
    if (distanceInKm <= 0) return 0;
    return Math.min(100, (distanceInKm / DAILY_GOAL) * 100);
  }
}

================
File: db/migrations/01_update_users_rls.sql
================
DO $$
BEGIN
    -- Only enable RLS if it's not already enabled
    IF NOT EXISTS (
        SELECT 1
        FROM pg_tables
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND rowsecurity = true
    ) THEN
        ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
    END IF;

    -- Create policies only if they don't exist
    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can view own record'
    ) THEN
        CREATE POLICY "Users can view own record"
        ON public.users FOR SELECT
        USING (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can update own record'
    ) THEN
        CREATE POLICY "Users can update own record"
        ON public.users FOR UPDATE
        USING (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can insert own record'
    ) THEN
        CREATE POLICY "Users can insert own record"
        ON public.users FOR INSERT
        WITH CHECK (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Service role can manage all records'
    ) THEN
        CREATE POLICY "Service role can manage all records"
        ON public.users
        USING (auth.role() = 'service_role');
    END IF;
END
$$;

-- Ensure permissions are granted
GRANT ALL ON public.users TO authenticated;
GRANT ALL ON public.users TO service_role;

================
File: features/auth/components/LoginScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { useTheme, TextInput, Button, Text } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { AuthStackParamList } from '../../../navigation/types';
import { useAuth } from '../../../context/AuthContext';

type LoginScreenProps = {
  navigation: StackNavigationProp<AuthStackParamList, 'Login'>;
};

export const LoginScreen: React.FC<LoginScreenProps> = ({ navigation }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [localError, setLocalError] = useState<string | null>(null);
  const theme = useTheme();
  const { signInWithGoogle, error: authError, isLoading } = useAuth();

  const handleLogin = async () => {
    if (!email || !password) {
      setLocalError('Please enter both email and password');
      return;
    }
    setLocalError(null);
    // Email/password login not implemented in this version
    setLocalError('Email/password login is not available. Please use Google Sign-In.');
  };

  const handleGoogleSignIn = async () => {
    setLocalError(null);
    try {
      await signInWithGoogle();
    } catch (err) {
      console.error('Google sign-in error:', err);
      setLocalError('Failed to sign in with Google. Please try again.');
    }
  };

  const error = localError || authError;

  return (
    <View style={styles.container}>
      <Text variant="headlineMedium" style={styles.title}>Welcome Back</Text>

      <TextInput
        label="Email"
        value={email}
        onChangeText={(text) => {
          setEmail(text);
          setLocalError(null);
        }}
        mode="outlined"
        style={styles.input}
        autoCapitalize="none"
        keyboardType="email-address"
        disabled={isLoading}
      />
      
      <TextInput
        label="Password"
        value={password}
        onChangeText={(text) => {
          setPassword(text);
          setLocalError(null);
        }}
        mode="outlined"
        style={styles.input}
        secureTextEntry
        disabled={isLoading}
      />

      {error && (
        <Text variant="bodySmall" style={[styles.error, { color: theme.colors.error }]}>
          {error}
        </Text>
      )}

      <Button
        mode="contained"
        onPress={handleLogin}
        loading={isLoading}
        style={styles.button}
        disabled={isLoading || !email || !password}
      >
        Sign In
      </Button>

      <Button
        mode="outlined"
        onPress={handleGoogleSignIn}
        loading={isLoading}
        style={styles.googleButton}
        disabled={isLoading}
        icon="google"
      >
        Sign in with Google
      </Button>

      <Button
        mode="text"
        onPress={() => navigation.navigate('Register')}
        style={styles.link}
        disabled={isLoading}
      >
        Don't have an account? Register
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 24,
  },
  title: {
    marginBottom: 32,
    textAlign: 'center',
  },
  input: {
    marginBottom: 16,
  },
  button: {
    marginTop: 16,
  },
  googleButton: {
    marginTop: 10,
  },
  error: {
    marginBottom: 16,
    textAlign: 'center',
  },
  link: {
    marginTop: 15,
  },
});

================
File: features/auth/components/RegisterScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { useTheme, Button, Text } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { AuthStackParamList } from '../../../navigation/types';
import { useAuth } from '../../../context/AuthContext';

type RegisterScreenProps = {
  navigation: StackNavigationProp<AuthStackParamList, 'Register'>;
};

export const RegisterScreen: React.FC<RegisterScreenProps> = ({ navigation }) => {
  const [localError, setLocalError] = useState<string | null>(null);
  const theme = useTheme();
  const { signInWithGoogle, error: authError, isLoading } = useAuth();

  const handleGoogleSignIn = async () => {
    setLocalError(null);
    try {
      await signInWithGoogle();
    } catch (err) {
      console.error('Google sign-in error:', err);
      setLocalError('Failed to sign in with Google. Please try again.');
    }
  };

  const error = localError || authError;

  return (
    <View style={styles.container}>
      <Text variant="headlineMedium" style={styles.title}>Create Account</Text>
      
      <Text variant="bodyMedium" style={styles.subtitle}>
        Create an account quickly and easily using your Google account
      </Text>

      {error && (
        <Text variant="bodySmall" style={[styles.error, { color: theme.colors.error }]}>
          {error}
        </Text>
      )}

      <Button
        mode="contained"
        onPress={handleGoogleSignIn}
        loading={isLoading}
        style={styles.googleButton}
        disabled={isLoading}
        icon="google"
      >
        Sign up with Google
      </Button>

      <Button
        mode="text"
        onPress={() => navigation.navigate('Login')}
        style={styles.link}
        disabled={isLoading}
      >
        Already have an account? Sign in
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 24,
  },
  title: {
    marginBottom: 16,
    textAlign: 'center',
  },
  subtitle: {
    textAlign: 'center',
    marginBottom: 32,
    opacity: 0.7,
  },
  googleButton: {
    marginTop: 16,
  },
  error: {
    marginBottom: 16,
    textAlign: 'center',
  },
  link: {
    marginTop: 15,
  },
});

================
File: features/auth/types/auth.ts
================
import { User as SupabaseUser } from '@supabase/supabase-js';

export type User = {
  id: string;
  email: string;
  displayName?: string;
  lastSignOutAt?: string;
  createdAt?: string;
  updatedAt?: string;
};

export const mapSupabaseUser = (user: SupabaseUser): User => ({
  id: user.id,
  email: user.email || '',
  displayName: user.user_metadata?.full_name,
  createdAt: user.created_at,
  updatedAt: user.updated_at,
  lastSignOutAt: user.last_sign_in_at,
});

export type AuthState = {
  isAuthenticated: boolean;
  user: User | null;
  isLoading: boolean;
  error: string | null;
};

export type AuthContextType = AuthState & {
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string) => Promise<void>;
  signInWithGoogle: () => Promise<void>;
  logout: () => Promise<void>;
};

================
File: features/health/hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { HealthMetrics, WeeklyMetrics } from '../types/health';
import { HealthServiceFactory } from '../services/factory';
import { HealthService } from '../services/types';
import AppleHealthKit from 'react-native-health';
import { getCurrentWeekStart } from '../../../core/constants/metrics';
import healthMetricsService from '../../../services/healthMetricsService';

const { Permissions } = AppleHealthKit.Constants;

const defaultPermissions = {
  permissions: {
    read: [
      Permissions.Steps,
      Permissions.DistanceWalkingRunning,
    ],
    write: [],
  },
};

const useHealthData = (profileId: string) => {
  const [healthService, setHealthService] = useState<HealthService | null>(null);
  const [metrics, setMetrics] = useState<HealthMetrics & WeeklyMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const initialize = useCallback(async () => {
    try {
      const service = await HealthServiceFactory.getService();
      setHealthService(service);
      
      const initialized = await service.initialize(defaultPermissions);
      if (initialized) {
        const permissions = await service.hasPermissions();
        setHasPermission(permissions);
        return permissions;
      }
      return false;
    } catch (err) {
      console.error('Health service initialization error:', err);
      setError('Failed to initialize health service');
      return false;
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions || !healthService) return;

    setLoading(true);
    setError(null);

    try {
      const [metrics, weeklySteps] = await Promise.all([
        healthService.getMetrics(),
        healthService.getWeeklySteps(getCurrentWeekStart())
      ]);

      // Only save metrics to Supabase if we have a valid UUID
      if (profileId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(profileId)) {
        await healthMetricsService.saveMetrics({
          user_id: profileId,
          date: new Date().toISOString().split('T')[0],
          steps: metrics.steps,
          distance: metrics.distance,
          score: metrics.score
        });
      }

      setMetrics({
        ...metrics,
        profileId,
        weeklySteps,
        weekStartDate: getCurrentWeekStart()
      });
    } catch (err) {
      console.error('Error fetching health data:', err);
      setError('Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions, profileId]);

  const refresh = useCallback(async () => {
    await fetchHealthData();
  }, [fetchHealthData]);

  useEffect(() => {
    const setupHealthData = async () => {
      const initialized = await initialize();
      if (initialized) {
        await fetchHealthData();
      }
    };

    setupHealthData();
  }, [initialize, fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    refresh,
    hasPermissions,
  };
};

export default useHealthData;

================
File: features/health/services/platforms/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
} from 'react-native-health';
import { Platform, InteractionManager } from 'react-native';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class AppleHealthService extends BaseHealthService {
  protected source = 'apple_health' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return new Promise((resolve) => {
      // Ensure initialization happens on main thread
      Platform.select({
        ios: () => {
          InteractionManager.runAfterInteractions(() => {
            AppleHealthKit.initHealthKit(config as HealthKitPermissions, (error: string) => {
              // Ensure callback executes on main thread
              requestAnimationFrame(() => {
                resolve(!error);
              });
            });
          });
        },
        default: () => resolve(false),
      })();
    });
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  protected async doHasPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getStepCount(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value);
          });
        });
      });
    });
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getDistanceWalkingRunning(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value / 1000); // Convert to kilometers
          });
        });
      });
    });
  }
}

================
File: features/health/services/platforms/GHealthConnectService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';
import { Platform } from 'react-native';
import NativeHealthConnect from '../NativeHealthConnect';

export class GHealthConnectService extends BaseHealthService {
  protected source = 'health_connect' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    if (Platform.OS !== 'android') return false;

    try {
      const availability = await NativeHealthConnect.isAvailable();
      if (!availability) {
        console.warn('Health Connect is not available on this device');
        return false;
      }
      
      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Health Connect initialization error:', error);
      return false;
    }
  }

  protected async doRequestPermissions(): Promise<boolean> {
    if (!this.initialized) return false;

    try {
      return await NativeHealthConnect.requestPermissions([
        'android.permission.health.READ_STEPS',
        'android.permission.health.READ_DISTANCE'
      ]);
    } catch (error) {
      console.error('Health Connect permission request error:', error);
      return false;
    }
  }

  protected async doHasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    
    try {
      // For now just attempt to read steps as a permissions check
      const now = new Date();
      await this.getDailySteps(now);
      return true;
    } catch (error) {
      return false;
    }
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      const steps = await NativeHealthConnect.getDailySteps(
        startTime.getTime(),
        endTime.getTime()
      );
      return steps || 0; // Return 0 if no data available
    } catch (error) {
      console.error('Error reading steps from Health Connect:', error);
      return 0; // Return 0 on error
    }
  }

  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      return await NativeHealthConnect.getDailyDistance(
        startTime.getTime(),
        endTime.getTime()
      );
    } catch (error) {
      console.error('Error reading distance from Health Connect:', error);
      throw error;
    }
  }
}

================
File: features/health/services/platforms/GoogleHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class GoogleHealthService extends BaseHealthService {
  protected source = 'google_fit' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    // TODO: Implement Google Fit initialization
    return false;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions request
    return false;
  }

  protected async doHasPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions check
    return false;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }
}

================
File: features/health/services/platforms/MockHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class MockHealthService extends BaseHealthService {
  protected source = 'manual' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return true;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    // Return a random number of steps between 5000 and 15000
    return Math.floor(Math.random() * (15000 - 5000 + 1)) + 5000;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    // Return a random distance between 3 and 10 kilometers
    return Number((Math.random() * (10 - 3) + 3).toFixed(2));
  }
}

================
File: features/health/services/base.ts
================
import { HealthService, HealthServiceConfig } from './types';
import { HealthMetrics } from '../types/health';
import { HealthScoring } from '../../../core/utils/scoring';
import { DataSource } from '../../../core/types/base';

export abstract class BaseHealthService implements HealthService {
  protected initialized = false;
  protected abstract source: DataSource;

  async initialize(config: HealthServiceConfig): Promise<boolean> {
    if (this.initialized) return true;
    const success = await this.doInitialize(config);
    this.initialized = success;
    return success;
  }

  protected abstract doInitialize(config: HealthServiceConfig): Promise<boolean>;

  async requestPermissions(): Promise<boolean> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    return this.doRequestPermissions();
  }

  protected abstract doRequestPermissions(): Promise<boolean>;

  async hasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    return this.doHasPermissions();
  }

  protected abstract doHasPermissions(): Promise<boolean>;

  async getMetrics(date: Date = new Date()): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }

    const [steps, distance] = await Promise.all([
      this.getDailySteps(date),
      this.getDailyDistance(date),
    ]);

    const now = new Date();
    const id = `metrics_${now.getTime()}`;

    const metrics: HealthMetrics = {
      id,
      profileId: '', // Set from the calling context
      date: date.toISOString(),
      steps,
      distance,
      score: 0,
      source: this.source,
      createdAt: now,
      updatedAt: now,
    };

    const score = HealthScoring.calculateScore(metrics);
    metrics.score = score.overall;

    return metrics;
  }

  abstract getDailySteps(date?: Date): Promise<number>;
  abstract getDailyDistance(date?: Date): Promise<number>;
  
  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    
    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }
}

================
File: features/health/services/factory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './types';
import { AppleHealthService } from './platforms/AppleHealthService';
import { GHealthConnectService } from './platforms/GHealthConnectService';
import { MockHealthService } from './platforms/MockHealthService';
import { getCurrentPlatform } from './platform';

export class HealthServiceFactory {
  static async getService(): Promise<HealthService> {
    const currentPlatform = await getCurrentPlatform();
    
    switch (currentPlatform.id) {
      case 'apple_health':
        return new AppleHealthService();
      case 'health_connect':
        return new GHealthConnectService();
      default:
        return new MockHealthService();
    }
  }
}

================
File: features/health/services/NativeHealthConnect.ts
================
import { NativeModules } from 'react-native';

const { HealthConnectModule } = NativeModules;

if (!HealthConnectModule) {
  throw new Error(
    'HealthConnectModule is not available. Did you properly link the native module?'
  );
}

interface NativeHealthConnectInterface {
  isAvailable(): Promise<boolean>;
  requestPermissions(permissions: string[]): Promise<boolean>;
  getDailySteps(startTime: number, endTime: number): Promise<number>;
  getDailyDistance(startTime: number, endTime: number): Promise<number>;
}

const NativeHealthConnect: NativeHealthConnectInterface = {
  isAvailable: HealthConnectModule.isAvailable,
  requestPermissions: HealthConnectModule.requestPermissions,
  getDailySteps: HealthConnectModule.getDailySteps,
  getDailyDistance: HealthConnectModule.getDailyDistance,
};

export default NativeHealthConnect;

================
File: features/health/services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

const appleHealthPlatform: HealthPlatform = {
  id: 'apple_health',
  name: 'Apple Health',
  version: '1.0.0',
  type: 'apple_health'
};

const healthConnectPlatform: HealthPlatform = {
  id: 'health_connect',
  name: 'Health Connect',
  version: '1.0.0',
  type: 'health_connect'
};

const manualPlatform: HealthPlatform = {
  id: 'manual',
  name: 'Manual Entry',
  version: '1.0.0',
  type: 'manual'
};

declare const HealthConnectClient: {
  isAvailable(): Promise<boolean>;
};

export const getCurrentPlatform = async (): Promise<HealthPlatform> => {
  if (Platform.OS === 'ios') {
    return appleHealthPlatform;
  }
  
  if (Platform.OS === 'android') {
    try {
      const isHealthConnectAvailable = await HealthConnectClient.isAvailable();
      if (isHealthConnectAvailable) {
        return healthConnectPlatform;
      }
    } catch (error) {
      console.warn('Error checking Health Connect availability:', error);
    }
    return manualPlatform;
  }
  
  return manualPlatform;
};

================
File: features/health/services/types.ts
================
import { HealthMetrics } from '../types/health';

export interface HealthServiceConfig {
  permissions: {
    read: string[];
    write: string[];
  };
  options?: Record<string, any>;
}

export interface HealthService {
  initialize(config: HealthServiceConfig): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  hasPermissions(): Promise<boolean>;
  getMetrics(date?: Date): Promise<HealthMetrics>;
  getDailySteps(date?: Date): Promise<number>;
  getDailyDistance(date?: Date): Promise<number>;
  getWeeklySteps(startDate: Date): Promise<number[]>;
}

================
File: features/health/types/health.ts
================
import { DataSource } from '../../../core/types/base';

export interface HealthScore {
  overall: number;
  categories: {
    steps: number;
    distance: number;
  };
  dailyVictory: boolean;
  bonusPoints: number;
}

export interface HealthMetrics {
  id: string;
  profileId: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
  source: DataSource;
  createdAt: Date;
  updatedAt: Date;
}

export interface WeeklyMetrics {
  weeklySteps: number[];
  weekStartDate: Date;
}

export type MetricType = 'steps' | 'distance' | 'score';

export interface HealthState {
  isInitialized: boolean;
  hasPermissions: boolean;
  isLoading: boolean;
  error: string | null;
  metrics: HealthMetrics | null;
}

================
File: features/home/components/GoalCelebration.tsx
================
import React, { useEffect } from 'react';
import { Modal, View, Animated, Share, Platform } from 'react-native';
import { useStyles } from '../styles/GoalCelebration.styles';
import { Surface, Text, useTheme, Button } from 'react-native-paper';
import { FontAwesome } from '@expo/vector-icons';
interface GoalCelebrationProps {
  visible: boolean;
  onClose: () => void;
  bonusPoints: number;
}

const GoalCelebration: React.FC<GoalCelebrationProps> = ({
  visible,
  onClose,
  bonusPoints,
}) => {
  const styles = useStyles();
  const theme = useTheme();
  const scale = new Animated.Value(0.5);
  const opacity = new Animated.Value(0);

  useEffect(() => {
    if (visible) {
      // Reset animation values
      scale.setValue(0.5);
      opacity.setValue(0);

      // Entrance animation
      Animated.parallel([
        Animated.spring(scale, {
          toValue: 1,
          useNativeDriver: true,
          damping: 15,
          stiffness: 150,
        }),
        Animated.timing(opacity, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();

    }
  }, [visible, scale, opacity, onClose]);

  if (!visible) return null;

  const handleShare = async (platform: string) => {
    const message = "I just reached my daily step goal! 🎉 Join me on my fitness journey!";
    const url = "https://yourapp.com/signup";
    
    try {
      if (Platform.OS === 'web') {
        // Web-specific sharing
        let shareUrl = '';
        switch (platform) {
          case 'facebook':
            shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(message)}`;
            break;
          case 'twitter':
            shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}&url=${encodeURIComponent(url)}`;
            break;
          case 'instagram':
            shareUrl = 'https://instagram.com';
            break;
          case 'whatsapp':
            shareUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(message)} ${encodeURIComponent(url)}`;
            break;
        }
        window.open(shareUrl, '_blank');
      } else {
        // Native sharing
        await Share.share({
          message: `${message}\n${url}`,
          url: url, // iOS only
          title: 'Share Goal Achievement',
        });
      }
      
      // Close celebration after successful share
      Animated.parallel([
        Animated.spring(scale, {
          toValue: 1.2,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start(() => {
        onClose();
      });
    } catch (error) {
      console.error('Error sharing:', error);
    }
  };

  return (
    <Modal transparent visible={visible} onRequestClose={onClose}>
      <View style={styles.container}>
        <View style={styles.backdrop} onTouchEnd={onClose} />
        <Animated.View
          style={[
            styles.contentContainer,
            {
              transform: [{ scale }],
              opacity,
            },
          ]}
        >
          <Surface
            style={[
              styles.surface,
              {
                backgroundColor: theme.dark
                  ? theme.colors.surfaceVariant
                  : theme.colors.surface,
              },
            ]}
          >
            <View style={styles.starsContainer}>
              {[...Array(3)].map((_, i) => (
                <Animated.View
                  key={i}
                  style={[
                    styles.starContainer,
                    {
                      transform: [
                        {
                          translateY: new Animated.Value(0).interpolate({
                            inputRange: [0, 1],
                            outputRange: [0, -10],
                          }),
                        },
                      ],
                    },
                  ]}
                >
                  <View style={[styles.star, { marginHorizontal: 4 }]}>
                    <FontAwesome
                      name="star"
                      size={32}
                      color={theme.colors.primary}
                    />
                  </View>
                </Animated.View>
              ))}
            </View>

            <Text
              variant="headlineMedium"
              style={[styles.title, { color: theme.colors.onSurface }]}
            >
              Congratulations!
            </Text>

            <Text
              variant="titleMedium"
              style={[styles.subtitle, { color: theme.colors.onSurface }]}
            >
              You've reached your daily step goal!
            </Text>

            <Text
              variant="titleLarge"
              style={[styles.points, { color: theme.colors.primary }]}
            >
              +{bonusPoints} Bonus Points Earned!
            </Text>

            <Text
              variant="bodyMedium"
              style={[styles.sharePrompt, { color: theme.colors.onSurfaceVariant }]}
            >
              Share your achievement to continue
            </Text>

            <View style={styles.shareButtonsContainer}>
              <Button
                mode="contained"
                onPress={() => handleShare('facebook')}
                style={[styles.shareButton, { backgroundColor: '#1877F2' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="facebook" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('twitter')}
                style={[styles.shareButton, { backgroundColor: '#1DA1F2' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="twitter" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('instagram')}
                style={[styles.shareButton, { backgroundColor: '#E4405F' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="instagram" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('whatsapp')}
                style={[styles.shareButton, { backgroundColor: '#25D366' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="whatsapp" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
            </View>
          </Surface>
        </Animated.View>
      </View>
    </Modal>
  );
};

export default GoalCelebration;

================
File: features/home/components/HomeScreen.tsx
================
import React, { useState, useEffect } from 'react';
import { View, ScrollView, RefreshControl } from 'react-native';
import { useTheme, Text, Surface, ActivityIndicator, IconButton } from 'react-native-paper';
import { StatusBar } from 'expo-status-bar';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import useHealthData from '../../health/hooks/useHealthData';
import { formatDistance, formatScore } from '../../../core/utils/formatting';
import { MetricCard } from './MetricCard';
import { MetricModal } from './MetricModal';
import { HealthMetrics, WeeklyMetrics } from '../../health/types/health';
import { TabParamList } from '../../../navigation/types';
import { MeasurementSystem } from '../../../core/types/base';
import GoalCelebration from './GoalCelebration';
import { useStyles } from '../styles/HomeScreen.styles';

// TODO: Replace with actual user profile management
const MOCK_PROFILE_ID = 'test_user_1';
// TODO: Make this configurable per user's preference
const DEFAULT_MEASUREMENT_SYSTEM: MeasurementSystem = 'imperial';

type MetricType = 'steps' | 'distance' | 'score';

interface ModalData {
  type: MetricType;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
    startDate?: Date;
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

type NavigationProp = NativeStackNavigationProp<TabParamList, 'Home'>;

export const HomeScreen: React.FC = () => {
  const theme = useTheme();
  const styles = useStyles();
  const navigation = useNavigation<NavigationProp>();
  const { metrics, loading, error, refresh } = useHealthData(MOCK_PROFILE_ID);
  const [refreshing, setRefreshing] = React.useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedMetric, setSelectedMetric] = useState<ModalData | null>(null);
  const [showCelebration, setShowCelebration] = useState(false);
  const [previousSteps, setPreviousSteps] = useState(0);

  useEffect(() => {
    if (metrics?.steps && metrics.steps >= 10000 && previousSteps < 10000) {
      setShowCelebration(true);
    }
    if (metrics?.steps) {
      setPreviousSteps(metrics.steps);
    }
  }, [metrics?.steps]);

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    await refresh();
    setRefreshing(false);
  }, [refresh]);

  const handleLeaderboardPress = () => {
    navigation.navigate('Leaderboard');
  };

  const handleMetricPress = (type: MetricType, metrics: HealthMetrics & WeeklyMetrics) => {
    let modalData: ModalData = {
      type,
      title: type.charAt(0).toUpperCase() + type.slice(1),
      value: type === 'distance' ? formatDistance(metrics[type], DEFAULT_MEASUREMENT_SYSTEM) : metrics[type].toString(),
      data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        values: type === 'steps' ? metrics.weeklySteps : [0, 0, 0, 0, 0, 0, metrics[type]],
        startDate: type === 'steps' ? metrics.weekStartDate : undefined
      },
    };

    setSelectedMetric(modalData);
    setModalVisible(true);
  };

  if (loading && !refreshing) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </Surface>
    );
  }

  if (error) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <Text variant="titleMedium" style={styles.errorText}>{error}</Text>
        <IconButton icon="refresh" onPress={refresh} />
      </Surface>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar style={theme.dark ? 'light' : 'dark'} />
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* <View style={styles.header}>
          <Text variant="headlineMedium" style={styles.title}>
            Health Dashboard
          </Text>
          <IconButton
            icon="trophy"
            mode="contained"
            onPress={handleLeaderboardPress}
            style={styles.leaderboardButton}
          />
        </View> */}

        <View style={styles.metricsContainer}>
          <MetricCard
            title="Steps"
            value={metrics?.steps?.toLocaleString() || '0'}
            icon="walk"
            metricType="steps"
            onPress={() => metrics && handleMetricPress('steps', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Distance"
            value={formatDistance(metrics?.distance || 0, DEFAULT_MEASUREMENT_SYSTEM)}
            icon="map-marker-distance"
            metricType="distance"
            onPress={() => metrics && handleMetricPress('distance', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Score"
            value={formatScore(metrics?.score || 0)}
            icon="star"
            metricType="score"
            onPress={() => metrics && handleMetricPress('score', metrics)}
            loading={loading}
            error={error}
          />
        </View>

        {selectedMetric && (
          <MetricModal
            visible={modalVisible}
            onClose={() => setModalVisible(false)}
            title={selectedMetric?.title || ''}
            value={selectedMetric?.value || ''}
            data={selectedMetric?.data}
            additionalInfo={selectedMetric?.additionalInfo}
          />
        )}
      </ScrollView>

      <GoalCelebration 
        visible={showCelebration}
        onClose={() => setShowCelebration(false)}
        bonusPoints={5}
      />
    </View>
  );
};

================
File: features/home/components/MetricCard.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Surface, Text, TouchableRipple, useTheme, ActivityIndicator } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { getMetricColor, MetricColorKey } from '../../../theme';
import { getCurrentWeekStart } from '../../../core/constants/metrics';

interface MetricCardProps {
  title: string;
  value: string | number;
  icon: keyof typeof MaterialCommunityIcons.glyphMap;
  metricType: MetricColorKey;
  onPress?: (startDate?: Date) => void;
  loading?: boolean;
  error?: string | null;
}

export const MetricCard: React.FC<MetricCardProps> = ({
  title,
  value,
  icon,
  metricType,
  onPress,
  loading,
  error,
}) => {
  const theme = useTheme();
  const metricColor = getMetricColor(metricType);
  const surfaceColor = theme.colors.surface;
  const borderColor = theme.colors.secondary;
  const borderWidth = 2;
  
  const handlePress = () => {
    if (onPress) {
      onPress(getCurrentWeekStart());
    }
  };

  const renderContent = () => {
    if (loading) {
      return <ActivityIndicator size="small" color={metricColor} />;
    }

    if (error) {
      return <Text style={[styles.errorText, { color: theme.colors.error }]}>{error}</Text>;
    }

    return (
      <>
        <MaterialCommunityIcons name={icon} size={24} color={metricColor} />
        <Text variant="titleLarge" style={[styles.value, { color: theme.colors.onSurface }]}>
          {value}
        </Text>
        <Text variant="labelMedium" style={[styles.title, { color: theme.colors.onSurfaceVariant }]}>
          {title}
        </Text>
      </>
    );
  };

  return (
    <Surface
      style={[
        styles.container,
        {
          backgroundColor: surfaceColor,
          borderColor: borderColor,
          shadowColor: metricColor,
        },
      ]}
      elevation={2}
    >
      <View style={styles.innerContainer}>
        <TouchableRipple
          onPress={handlePress}
          style={styles.touchable}
          rippleColor={metricColor}
          disabled={loading || !!error}
        >
          <>{renderContent()}</>
        </TouchableRipple>
      </View>
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: 8,
    borderRadius: 16,
    minHeight: 120,
    borderWidth: 2,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  innerContainer: {
    flex: 1,
    overflow: 'hidden',
    borderRadius: 12,
  },
  touchable: {
    flex: 1,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  value: {
    marginTop: 8,
    fontWeight: '600',
  },
  title: {
    marginTop: 4,
  },
  errorText: {
    textAlign: 'center',
    padding: 8,
  },
});

================
File: features/home/components/MetricModal.tsx
================
import React from 'react';
import { StyleSheet, View, Dimensions } from 'react-native';
import { Modal, Portal, Text, IconButton, Surface, useTheme, MD3Theme } from 'react-native-paper';
import { LineChart } from 'react-native-chart-kit';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

interface MetricModalProps {
  visible: boolean;
  onClose: () => void;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
    startDate?: Date;
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

const formatDateLabel = (date: Date): string => {
  const today = new Date();
  const isToday = date.toDateString() === today.toDateString();
  return isToday ? 'Today' : date.toLocaleDateString('en-US', { weekday: 'short' });
};

const generateWeekLabels = (startDate: Date): string[] => {
  const labels: string[] = [];
  const currentDate = new Date(startDate);
  
  // Generate labels for the past 6 days plus today
  for (let i = 0; i < 7; i++) {
    labels.push(formatDateLabel(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return labels;
};

export const MetricModal: React.FC<MetricModalProps> = ({
  visible,
  onClose,
  title,
  value,
  data,
  additionalInfo,
}) => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();

  const styles = StyleSheet.create({
    modalContainer: {
      margin: 0,
      justifyContent: 'flex-end',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      padding: 24,
      borderTopLeftRadius: 28,
      borderTopRightRadius: 28,
      borderWidth: 2,
      borderColor: theme.colors.secondary,
    },
    closeButton: {
      position: 'absolute',
      right: 8,
      top: 8,
    },
    modalTitle: {
      marginTop: 8,
      marginBottom: 4,
    },
    modalValue: {
      marginBottom: 16,
    },
    chartContainer: {
      alignItems: 'center',
      marginVertical: 16,
    },
    additionalInfoContainer: {
      marginTop: 16,
      gap: 12,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
  });

  const chartConfig = {
    backgroundColor: theme.colors.surface,
    backgroundGradientFrom: theme.colors.primaryContainer,
    backgroundGradientTo: theme.colors.surface,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(32, 178, 170, ${opacity})`, // Light sea green
    labelColor: (opacity = 1) => theme.colors.onSurface,
    style: {
      borderRadius: 16,
    },
    propsForDots: {
      r: '6',
      strokeWidth: '2',
      stroke: '#20B2AA', // Light sea green
      fill: theme.colors.surface,
    },
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onClose}
        contentContainerStyle={[
          styles.modalContainer,
          { paddingBottom: insets.bottom },
          { backgroundColor: theme.colors.surface }
        ]}
      >
        <Surface style={styles.modalContent} elevation={0}>
          <IconButton
            icon="close"
            size={24}
            onPress={onClose}
            style={styles.closeButton}
          />

          <Text variant="headlineMedium" style={styles.modalTitle}>
            {title}
          </Text>
          <Text variant="displaySmall" style={[styles.modalValue, { color: theme.colors.primary }]}>
            {value}
          </Text>

          {data && data.values.length > 0 && (
            <View style={styles.chartContainer}>
              <LineChart
                data={{
                  labels: data.startDate ? generateWeekLabels(data.startDate) : data.labels,
                  datasets: [{ data: data.values }],
                }}
                width={Dimensions.get('window').width - 48}
                height={220}
                chartConfig={chartConfig}
                bezier
                style={{
                  marginVertical: 8,
                  borderRadius: 16,
                }}
              />
            </View>
          )}

          {additionalInfo && additionalInfo.length > 0 && (
            <Surface style={styles.additionalInfoContainer} elevation={0}>
              {additionalInfo.map((info, index) => (
                <View key={index} style={styles.infoRow}>
                  <Text variant="labelLarge" style={{ color: theme.colors.onSurfaceVariant }}>
                    {info.label}
                  </Text>
                  <Text variant="bodyLarge" style={{ color: theme.colors.onSurface }}>
                    {info.value}
                  </Text>
                </View>
              ))}
            </Surface>
          )}
        </Surface>
      </Modal>
    </Portal>
  );
};

================
File: features/home/styles/GoalCelebration.styles.ts
================
import { StyleSheet } from 'react-native';
import { MD3Theme, useTheme } from 'react-native-paper';

const createStyles = (theme: MD3Theme) => StyleSheet.create({
    sharePrompt: {
        marginTop: 16,
        marginBottom: 8,
        textAlign: 'center',
        color: theme.colors.onSurface,
    },
    shareButtonsContainer: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        marginTop: 24,
        width: '100%',
        gap: 16,
    },
    shareButton: {
        width: 60,
        height: 60,
        borderRadius: 20,
        justifyContent: 'center',
        alignItems: 'center',
        alignSelf: 'center',
        backgroundColor: theme.colors.primaryContainer,
    },
    buttonContent: {
        height: '100%',
        width: '100%',
        alignItems: 'center',
        justifyContent: 'center',
        flexDirection: 'row',
        marginLeft: 15,
    },
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    backdrop: {
        ...StyleSheet.absoluteFillObject,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    contentContainer: {
        width: '80%',
        maxWidth: 400,
        alignItems: 'center',
    },
    surface: {
        padding: 24,
        borderRadius: 16,
        alignItems: 'center',
        elevation: 4,
        width: '100%',
        backgroundColor: theme.colors.surface,
        borderColor: theme.colors.surfaceVariant,
        borderWidth: 1,
    },
    starsContainer: {
        flexDirection: 'row',
        marginBottom: 16,
        justifyContent: 'center',
    },
    starContainer: {
        padding: 4,
    },
    title: {
        fontWeight: 'bold',
        textAlign: 'center',
        marginBottom: 8,
        color: theme.colors.onSurface,
    },
    subtitle: {
        textAlign: 'center',
        marginBottom: 16,
        color: theme.colors.onSurfaceVariant,
    },
    points: {
        fontWeight: 'bold',
        textAlign: 'center',
        color: theme.colors.primary,
    },
    star: {
        width: 32,
        height: 32,
        justifyContent: 'center',
        alignItems: 'center',
        color: theme.colors.primary,
    },
    starIcon: {
        fontSize: 32,
        lineHeight: 32,
        color: theme.colors.primary,
    },
});

export const useStyles = () => {
    const theme = useTheme();
    return createStyles(theme);
};

================
File: features/home/styles/HomeScreen.styles.ts
================
import { StyleSheet } from 'react-native';
import { MD3Theme, useTheme } from 'react-native-paper';

const createStyles = (theme: MD3Theme) => StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#20B2AA',
  },
  content: {
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    marginBottom: 16,
    color: theme.colors.error,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 16,
    
    elevation: 2,
    shadowColor: theme.colors.primary,
    shadowOffset: {
      width: 0,
      height: 2,
    },

    
  },
  title: {
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  leaderboardButton: {
    margin: 0,
  },
  metricsContainer: {
    width: '100%',
    alignItems: 'stretch',
    gap: 16,
    paddingHorizontal: 8,
  },
  scrollView: {
    flex: 1,
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export const useStyles = () => {
  const theme = useTheme();
  return createStyles(theme);
};

================
File: features/leaderboard/components/LeaderboardScreen.tsx
================
import React, { useEffect, useState } from 'react';
import { View, Text, ScrollView, StyleSheet } from 'react-native';
import healthMetricsService from '../../../services/healthMetricsService';

interface LeaderboardEntry {
  id: string;
  name: string;
  avatarUrl?: string;
  rank: number;
  metrics: {
    steps: number;
    distance: number;
  };
  score: {
    overall: number;
    categories: {
      steps: number;
      distance: number;
    };
    bonusPoints: number;
  };
}

export const LeaderboardScreen: React.FC = () => {
  const [leaderboardData, setLeaderboardData] = useState<LeaderboardEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchLeaderboard = async () => {
      try {
        const today = new Date().toISOString().split('T')[0];
        const leaderboardData = await healthMetricsService.getLeaderboard(today);
        
        const formattedData = leaderboardData.map((entry, index) => ({
          id: entry.user_id,
          name: entry.users[0].display_name,
          avatarUrl: entry.users[0].photo_url,
          rank: index + 1,
          metrics: {
            steps: entry.steps,
            distance: entry.distance,
          },
          score: {
            overall: entry.score,
            categories: {
              steps: Math.round(entry.score * 0.9),
              distance: Math.round(entry.score * 0.95),
            },
            bonusPoints: 5,
          },
        }));

        setLeaderboardData(formattedData);
      } catch (error) {
        console.error('Error fetching leaderboard:', error);
        setError('Failed to fetch leaderboard data');
      } finally {
        setLoading(false);
      }
    };

    fetchLeaderboard();
  }, []);

  if (loading) {
    return (
      <View style={styles.container}>
        <Text>Loading leaderboard...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.container}>
        <Text style={styles.errorText}>{error}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container}>
      {leaderboardData.map((entry) => (
        <View key={entry.id} style={styles.entryContainer}>
          <View style={styles.rankContainer}>
            <Text style={styles.rankText}>#{entry.rank}</Text>
          </View>
          <View style={styles.detailsContainer}>
            <Text style={styles.nameText}>{entry.name}</Text>
            <Text style={styles.metricsText}>
              Steps: {entry.metrics.steps.toLocaleString()} • Distance: {entry.metrics.distance.toFixed(2)}km
            </Text>
            <Text style={styles.scoreText}>Score: {entry.score.overall}</Text>
          </View>
        </View>
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 16,
  },
  entryContainer: {
    flexDirection: 'row',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    alignItems: 'center',
  },
  rankContainer: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#f0f0f0',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  rankText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  detailsContainer: {
    flex: 1,
  },
  nameText: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  metricsText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 2,
  },
  scoreText: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },
  errorText: {
    color: 'red',
    textAlign: 'center',
  },
});

================
File: features/leaderboard/data/mockData.ts
================
import { LeaderboardEntry } from '../types/leaderboard';

const MOCK_AVATARS = [
  'https://i.pravatar.cc/150?img=47',
  'https://i.pravatar.cc/150?img=32',
  'https://i.pravatar.cc/150?img=28',
  'https://i.pravatar.cc/150?img=15',
  'https://i.pravatar.cc/150?img=56',
  'https://i.pravatar.cc/150?img=12',
  'https://i.pravatar.cc/150?img=23',
  'https://i.pravatar.cc/150?img=35',
  'https://i.pravatar.cc/150?img=41',
  'https://i.pravatar.cc/150?img=52',
];

const MOCK_NAMES = [
  'Sarah Johnson',
  'Michael Chen',
  'Emma Wilson',
  'James Rodriguez',
  'Lisa Thompson',
  'David Park',
  'Maria Garcia',
  'Alex Turner',
  'Rachel Kim',
  'Omar Hassan',
];

interface UserData {
  id: string;
  name: string;
  avatarUrl?: string;
  metrics: {
    steps: number;
    distance: number;
  };
  score: number;
}

export const generateMockLeaderboardData = (userData: UserData): LeaderboardEntry[] => {
  // Generate mock competitors with varying scores around the user's score
  const baseEntries: LeaderboardEntry[] = MOCK_NAMES.map((name, index) => {
    // Create some variance in scores but keep them relatively close to user's score
    const scoreVariance = Math.random() * 20 - 10; // Random number between -10 and 10
    const competitorScore = Math.max(0, Math.min(100, userData.score + scoreVariance));
    
    return {
      id: `mock-${index + 2}`, // Start from 2 since user will be 1
      name,
      avatarUrl: MOCK_AVATARS[index],
      metrics: {
        steps: Math.round(competitorScore * 100), // Scale steps based on score
        distance: Number((competitorScore * 0.1).toFixed(1)), // Scale distance based on score
      },
      score: {
        overall: Math.round(competitorScore),
        categories: {
          steps: Math.round(competitorScore * 0.9),
          distance: Math.round(competitorScore * 0.95),
        },
        bonusPoints: Math.round(Math.random() * 10), // Random bonus points 0-10
      },
      rank: 0, // Will be calculated after sorting
    };
  });

  // Create user entry using actual user data
  const userEntry: LeaderboardEntry = {
    id: userData.id,
    name: userData.name,
    avatarUrl: userData.avatarUrl || 'https://i.pravatar.cc/150?img=68', // Fallback avatar
    metrics: {
      steps: userData.metrics.steps,
      distance: userData.metrics.distance,
    },
    score: {
      overall: userData.score,
      categories: {
        steps: Math.round(userData.score * 0.9),
        distance: Math.round(userData.score * 0.95),
      },
      bonusPoints: 5,
    },
    rank: 0,
  };

  // Combine and sort entries
  const allEntries = [userEntry, ...baseEntries];
  const sortedEntries = allEntries.sort((a, b) => b.score.overall - a.score.overall);

  // Assign ranks based on sorted position
  return sortedEntries.map((entry, index) => ({
    ...entry,
    rank: index + 1,
  }));
};

================
File: features/leaderboard/styles/LeaderboardScreen.styles.ts
================
import { StyleSheet } from 'react-native';
import { ExtendedTheme } from '../../../theme';

export const createStyles = (theme: ExtendedTheme) =>
  StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: '#20B2AA', // Seafoam green
    },
    listContainer: {
      paddingHorizontal: 16,
      paddingTop: 16,
    },
    entryContainer: {
      backgroundColor: theme.colors.card,
      borderRadius: 12,
      marginBottom: 12,
      padding: 16,
      shadowColor: theme.colors.shadow,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 4,
      elevation: 3,
    },
    userEntryContainer: {
      borderWidth: 2,
      borderColor: theme.colors.primary,
    },
    headerRow: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'space-between',
    },
    rankContainer: {
      width: 32,
      height: 32,
      borderRadius: 16,
      backgroundColor: theme.colors.secondary + '20',
      alignItems: 'center',
      justifyContent: 'center',
      marginRight: 12,
    },
    rankText: {
      ...theme.textVariants.body,
      color: theme.colors.text,
      fontWeight: 'bold',
    },
    userInfo: {
      flex: 1,
      flexDirection: 'row',
      alignItems: 'center',
    },
    avatar: {
      width: 40,
      height: 40,
      borderRadius: 20,
      marginRight: 12,
    },
    nameText: {
      ...theme.textVariants.body,
      color: theme.colors.text,
      fontWeight: '600',
    },
    scoreContainer: {
      backgroundColor: theme.colors.secondary + '10',
      paddingHorizontal: 12,
      paddingVertical: 6,
      borderRadius: 16,
    },
    scoreText: {
      ...theme.textVariants.body,
      color: theme.colors.text,
      fontWeight: 'bold',
    },
    detailsContainer: {
      marginTop: 12,
      paddingTop: 12,
      borderTopWidth: 1,
      borderTopColor: theme.colors.border,
    },
    metricRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: 8,
    },
    metricLabel: {
      ...theme.textVariants.caption,
      color: theme.colors.textSecondary,
    },
    metricValue: {
      ...theme.textVariants.body,
      color: theme.colors.text,
      fontWeight: '500',
    },
    expandButton: {
      padding: 8,
      marginLeft: 8,
    },
    loadingContainer: {
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
    },
    errorText: {
      ...theme.textVariants.body,
      color: theme.colors.error,
      textAlign: 'center',
      margin: 16,
    },
  });

================
File: features/leaderboard/types/leaderboard.ts
================
export interface LeaderboardMetrics {
  steps: number;
  distance: number;
}

export interface CategoryScores {
  steps: number;
  distance: number;
}

export interface UserScore {
  overall: number;
  categories: CategoryScores;
  bonusPoints: number;
}

export interface LeaderboardEntry {
  id: string;
  name: string;
  avatarUrl: string;
  metrics: LeaderboardMetrics;
  score: UserScore;
  rank: number;
}

export interface LeaderboardState {
  entries: LeaderboardEntry[];
  isLoading: boolean;
  error: string | null;
  selectedEntry: string | null;
}

================
File: features/profile/components/ProfileScreen.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Button, Avatar, useTheme, HelperText } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { useAuth } from '../../../context/AuthContext';
import { User } from '../../../services/authService';

type RootStackParamList = {
  Profile: undefined;
  Settings: undefined;
  Login: undefined;
};

type ProfileScreenProps = {
  navigation: StackNavigationProp<RootStackParamList, 'Profile'>;
};

export const ProfileScreen: React.FC<ProfileScreenProps> = ({ navigation }) => {
  const paperTheme = useTheme();
  const { user, signOut, isLoading } = useAuth();
  const [displayName, setDisplayName] = useState('');
  const [editMode, setEditMode] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [updateLoading, setUpdateLoading] = useState(false);

  useEffect(() => {
    setDisplayName(user?.name || '');
  }, [user]);

  const handleLogout = useCallback(async () => {
    try {
      await signOut();
    } catch (err) {
      console.error('[ProfileScreen] Logout error:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
    }
  }, [signOut]);

  const handleProfileUpdate = useCallback(async () => {
    if (!displayName.trim()) {
      setError('Display name cannot be empty');
      return;
    }
    
    try {
      setUpdateLoading(true);
      setError(null);
      // TODO: Implement profile update
      setEditMode(false);
    } catch (err) {
      console.error('[ProfileScreen] Profile update error:', err);
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setUpdateLoading(false);
    }
  }, [displayName]);

  return (
    <View style={[styles.container, { backgroundColor: paperTheme.colors.background }]}>
      <ScrollView style={styles.content}>
        <View style={styles.avatarContainer}>
          <Avatar.Image
            size={100}
            source={user?.photoUrl ? { uri: user.photoUrl } : { uri: 'https://via.placeholder.com/100' }}
          />
        </View>

        <View style={styles.form}>
          {editMode ? (
            <>
              <TextInput
                label="Display Name"
                value={displayName}
                onChangeText={setDisplayName}
                mode="outlined"
                disabled={updateLoading}
                error={!!error}
              />
              {error && <HelperText type="error">{error}</HelperText>}
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={handleProfileUpdate}
                  loading={updateLoading}
                  disabled={updateLoading}
                  style={styles.button}
                >
                  Save
                </Button>
                <Button
                  mode="outlined"
                  onPress={() => {
                    setEditMode(false);
                    setDisplayName(user?.name || '');
                    setError(null);
                  }}
                  disabled={updateLoading}
                  style={styles.button}
                >
                  Cancel
                </Button>
              </View>
            </>
          ) : (
            <>
              <TextInput
                label="Display Name"
                value={user?.name || ''}
                disabled
                mode="outlined"
              />
              <TextInput
                label="Email"
                value={user?.email || ''}
                disabled
                mode="outlined"
              />
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={() => setEditMode(true)}
                  style={styles.button}
                >
                  Edit Profile
                </Button>
                <Button
                  mode="outlined"
                  onPress={handleLogout}
                  loading={isLoading}
                  disabled={isLoading}
                  style={styles.button}
                >
                  Logout
                </Button>
              </View>
            </>
          )}
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  avatarContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  form: {
    gap: 16,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  button: {
    flex: 1,
    marginHorizontal: 4,
  },
});

================
File: features/profile/types/profile.ts
================
export interface Profile {
  id: string;
  email: string;
  display_name: string;
  photo_url: string;
  settings: {
    measurementSystem: 'metric' | 'imperial';
    notifications: boolean;
    privacyLevel: 'private' | 'friends' | 'public';
    dailyGoals: {
      steps: number;
      sleep: number;  // in minutes
      water: number;  // in milliliters
    };
  };
  created_at?: string;
  updated_at?: string;
}

================
File: navigation/AppStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AppStackParamList } from './types';
import { TabNavigator } from './TabNavigator';
import { useTheme } from 'react-native-paper';

const Stack = createNativeStackNavigator<AppStackParamList>();

export const AppStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Stack.Screen 
        name="MainTabs" 
        component={TabNavigator}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AuthStackParamList } from './types';
import { useTheme } from 'react-native-paper';
import { LoginScreen } from '../features/auth/components/LoginScreen';
import { RegisterScreen } from '../features/auth/components/RegisterScreen';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export const AuthStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
        headerShown: false, // Hide header for all auth screens
      }}
    >
      <Stack.Screen 
        name="Login" 
        component={LoginScreen}
      />
      <Stack.Screen 
        name="Register" 
        component={RegisterScreen}
      />
    </Stack.Navigator>
  );
};

================
File: navigation/RootNavigator.tsx
================
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useApp } from '../context/AppContext';
import { useAuth } from '../context/AuthContext';
import { AppStack } from './AppStack';
import { AuthStack } from './AuthStack';
import { ActivityIndicator, View } from 'react-native';

// Inline LoadingScreen component until we create a separate one
const LoadingScreen = () => {
  const { theme } = useApp();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff' }}>
      <ActivityIndicator size="large" color={theme.colors.primary} />
    </View>
  );
};

const Stack = createNativeStackNavigator();

export const RootNavigator = () => {
  const { theme } = useApp();
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <NavigationContainer theme={theme}>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          <Stack.Screen name="App" component={AppStack} />
        ) : (
          <Stack.Screen name="Auth" component={AuthStack} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

================
File: navigation/TabNavigator.tsx
================
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme } from '@react-navigation/native';
import { ExtendedTheme } from '../theme';
import { HomeScreen } from '../features/home/components/HomeScreen';
import { LeaderboardScreen } from '../features/leaderboard/components/LeaderboardScreen';
import { ProfileScreen } from '../features/profile/components/ProfileScreen';

const Tab = createBottomTabNavigator();

export const TabNavigator = () => {
  const theme = useTheme() as unknown as ExtendedTheme;

  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.outline,
        },
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          title: 'Health Dashboard',
        }}
      />
      <Tab.Screen
        name="Leaderboard"
        component={LeaderboardScreen}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
      />
    </Tab.Navigator>
  );
};

================
File: navigation/types.ts
================
export type RootStackParamList = {
  Auth: undefined;
  App: undefined;
};

export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
};

export type AppStackParamList = {
  MainTabs: undefined;
};

export type TabParamList = {
  Home: undefined;
  Leaderboard: undefined;
  Profile: undefined;
};

================
File: services/authService.ts
================
import { supabase } from '../utils/supabase';
import { User as SupabaseUser } from '@supabase/supabase-js';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { User, mapSupabaseUser } from '../features/auth/types/auth';

class AuthService {
  private static instance: AuthService;
  private currentUser: User | null = null;
  private listeners: Set<(user: User | null) => void> = new Set();

  private constructor() {
    this.initializeAuth();
  }

  private async initializeAuth() {
    const { data: { session } } = await supabase.auth.getSession();
    if (session?.user) {
      this.currentUser = await this.createAppUserFromSupabaseUser(session.user);
      this.notifyListeners();
    }

    supabase.auth.onAuthStateChange(async (event, session) => {
      if (session?.user) {
        const appUser = await this.createAppUserFromSupabaseUser(session.user);
        this.currentUser = appUser;
      } else {
        this.currentUser = null;
      }
      this.notifyListeners();
    });
  }

  private async createAppUserFromSupabaseUser(supabaseUser: SupabaseUser): Promise<User> {
    const { data: profile } = await supabase
      .from('users')
      .select('*')
      .eq('id', supabaseUser.id)
      .single();

    if (!profile) {
      const newProfile = {
        id: supabaseUser.id,
        email: supabaseUser.email!,
        display_name: supabaseUser.user_metadata.full_name || supabaseUser.email!.split('@')[0],
        photo_url: supabaseUser.user_metadata.avatar_url,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        auth_provider: 'google',
        settings: {
          measurementSystem: 'metric',
          notifications: true,
          privacyLevel: 'private'
        }
      };

      const { error } = await supabase.from('users').insert([newProfile]);
      if (error) throw error;

      return mapSupabaseUser(supabaseUser);
    }

    return mapSupabaseUser(supabaseUser);
  }

  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }

  public async signInWithGoogle(idToken: string): Promise<void> {
    try {
      const { data, error } = await supabase.auth.signInWithIdToken({
        provider: 'google',
        token: idToken,
        nonce: undefined, // Let Supabase handle the nonce
      });

      if (error) throw error;
      
      if (data.user) {
        this.currentUser = await this.createAppUserFromSupabaseUser(data.user);
        this.notifyListeners();
      } else {
        throw new Error('No user data returned from authentication');
      }
    } catch (error) {
      console.error('Supabase auth error:', error);
      throw error;
    }
  }

  public async signOut(): Promise<void> {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    this.currentUser = null;
    this.notifyListeners();
    await AsyncStorage.clear();
  }

  public getCurrentUser(): User | null {
    return this.currentUser;
  }

  public addAuthStateListener(listener: (user: User | null) => void): () => void {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.currentUser));
  }
}

export default AuthService.getInstance();

================
File: services/healthMetricsService.ts
================
import { supabase } from '../utils/supabase';

interface HealthMetricsData {
  user_id: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
}

class HealthMetricsService {
  private static instance: HealthMetricsService;

  private constructor() {}

  public static getInstance(): HealthMetricsService {
    if (!HealthMetricsService.instance) {
      HealthMetricsService.instance = new HealthMetricsService();
    }
    return HealthMetricsService.instance;
  }

  public async saveMetrics(metrics: HealthMetricsData): Promise<void> {
    const { error } = await supabase
      .from('health_metrics')
      .upsert([metrics], {
        onConflict: 'user_id,date'
      });

    if (error) throw error;
  }

  public async getLeaderboard(date: string) {
    const { data, error } = await supabase
      .from('health_metrics')
      .select(`
        user_id,
        steps,
        distance,
        score,
        users (
          display_name,
          photo_url
        )
      `)
      .eq('date', date)
      .order('score', { ascending: false });

    if (error) throw error;
    return data;
  }
}

export default HealthMetricsService.getInstance();

================
File: services/profileService.ts
================
import { supabase } from '../utils/supabase';
import { Profile } from '../features/profile/types/profile';
import { User } from '../features/auth/types/auth';
import { MeasurementSystem, PrivacyLevel } from '../core/types/base';

export const profileService = {
  async createProfile(user: User) {
    const { data, error } = await supabase
      .from('users')
      .insert([
        {
          id: user.id,
          email: user.email,
          display_name: user.displayName || '',
          photo_url: '',
          settings: {
            measurementSystem: 'metric',
            notifications: true,
            privacyLevel: 'private',
            dailyGoals: {
              steps: 10000,
              sleep: 480,
              water: 2000
            }
          }
        }
      ])
      .select()
      .single();

    if (error) {
      console.error('Error creating profile:', error);
      throw error;
    }

    return data;
  },

  async getProfile(userId: string) {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .maybeSingle();

    if (error && error.code !== 'PGRST116') {
      console.error('Error fetching profile:', error);
      throw error;
    }

    return data;
  },

  async updateProfile(userId: string, updates: Partial<Profile>) {
    const { data, error } = await supabase
      .from('users')
      .update(updates)
      .eq('id', userId)
      .select()
      .single();

    if (error) {
      console.error('Error updating profile:', error);
      throw error;
    }

    return data;
  }
};

================
File: services/storageService.ts
================
import AsyncStorage from '@react-native-async-storage/async-storage';

const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
} as const;

export class StorageService {
  static async setAuthToken(token: string): Promise<void> {
    await AsyncStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, token);
  }

  static async getAuthToken(): Promise<string | null> {
    return AsyncStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
  }

  static async removeAuthToken(): Promise<void> {
    await AsyncStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);
  }

  static async setUserData(userData: any): Promise<void> {
    await AsyncStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(userData));
  }

  static async getUserData(): Promise<any | null> {
    const data = await AsyncStorage.getItem(STORAGE_KEYS.USER_DATA);
    return data ? JSON.parse(data) : null;
  }

  static async removeUserData(): Promise<void> {
    await AsyncStorage.removeItem(STORAGE_KEYS.USER_DATA);
  }

  static async clearAll(): Promise<void> {
    await AsyncStorage.multiRemove([
      STORAGE_KEYS.AUTH_TOKEN,
      STORAGE_KEYS.USER_DATA,
    ]);
  }
}

================
File: theme/index.ts
================
import { MD3DarkTheme, MD3LightTheme } from 'react-native-paper';
import { MD3Colors } from 'react-native-paper/lib/typescript/types';
import { Theme as NavigationTheme } from '@react-navigation/native';
import { MD3Theme } from 'react-native-paper/lib/typescript/types';

export interface ExtendedTheme extends MD3Theme, NavigationTheme {
  colors: MD3Colors & {
    card: string;
    text: string;
    border: string;
    notification: string;
    shadow: string;
    textSecondary: string;
  };
  textVariants: {
    body: {
      fontSize: number;
      lineHeight: number;
    };
    caption: {
      fontSize: number;
      lineHeight: number;
    };
  };
  metrics: {
    steps: string;
    distance: string;
    score: string;
    calories: string;
    sleep: string;
  };
}

// Custom colors for metrics
const metricColors = {
  steps: '#20B2AA',      // Light sea green
  distance: '#20B2AA',   // Light sea green
  score: '#9B59B6',      // Purpureus
  calories: '#FF6B6B',   // Light red
  sleep: '#9B59B6',      // Purpureus
};

export const lightColors: MD3Colors = {
  ...MD3LightTheme.colors,
  primary: '#98DFD6',  // Seafoam green
  onPrimary: '#FFFFFF',
  primaryContainer: '#E0F7F6',
  onPrimaryContainer: '#003D3A',
  secondary: '#98DFD6',  // Changed to match primary
  onSecondary: '#FFFFFF',
  secondaryContainer: '#F3E5F5',
  onSecondaryContainer: '#4A2D59',
  background: '#FFFFFF',
  surface: '#FFFFFF',
  surfaceVariant: '#F5F5F5',
  onSurfaceVariant: '#666666',
  error: '#FF6B6B',
  onError: '#FFFFFF',
  errorContainer: '#FFE5E5',
  onErrorContainer: '#660000',
};

export const darkColors: MD3Colors = {
  ...MD3DarkTheme.colors,
  primary: '#20B2AA',
  onPrimary: '#FFFFFF',
  primaryContainer: '#004D40',
  onPrimaryContainer: '#E0F7F6',
  secondary: '#9B59B6',
  onSecondary: '#FFFFFF',
  secondaryContainer: '#4A2D59',
  onSecondaryContainer: '#F3E5F5',
  background: '#121212',
  surface: '#121212',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#CCCCCC',
  error: '#FF6B6B',
  onError: '#FFFFFF',
  errorContainer: '#660000',
  onErrorContainer: '#FFE5E5',
};

const textVariants = {
  body: {
    fontSize: 16,
    lineHeight: 24,
  },
  caption: {
    fontSize: 12,
    lineHeight: 16,
  },
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: {
    ...lightColors,
    shadow: '#000000',
    textSecondary: '#666666',
  },
  metrics: metricColors,
  textVariants,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...darkColors,
    shadow: '#000000',
    textSecondary: '#999999',
  },
  metrics: metricColors,
  textVariants,
};

// Create a custom theme that combines MD3Theme and NavigationTheme
export const customLightTheme: ExtendedTheme = {
  ...lightTheme,
  colors: {
    ...lightColors,
    card: lightColors.surface,
    text: lightColors.onSurface,
    border: lightColors.outline,
    notification: lightColors.error,
    shadow: '#000000',
    textSecondary: '#666666',
  },
  textVariants,
  metrics: metricColors,
};

export const customDarkTheme: ExtendedTheme = {
  ...darkTheme,
  colors: {
    ...darkColors,
    card: darkColors.surface,
    text: darkColors.onSurface,
    border: darkColors.outline,
    notification: darkColors.error,
    shadow: '#000000',
    textSecondary: '#999999',
  },
  textVariants,
  metrics: metricColors,
};

export type AppTheme = ExtendedTheme;
export type MetricColorKey = keyof typeof metricColors;

// Helper function to get metric color
export const getMetricColor = (metricType: MetricColorKey): string => {
  return metricColors[metricType] || metricColors.score;
};

================
File: utils/supabase.ts
================
import 'react-native-url-polyfill/auto'
import AsyncStorage from '@react-native-async-storage/async-storage'
import { createClient } from '@supabase/supabase-js'
import Constants from 'expo-constants'

const supabaseConfig = Constants.expoConfig?.extra?.supabase;

if (!supabaseConfig?.url || !supabaseConfig?.anonKey) {
  throw new Error('Missing Supabase configuration. Check your app.config.js and .env files.')
}

export const supabase = createClient(supabaseConfig.url, supabaseConfig.anonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
})
