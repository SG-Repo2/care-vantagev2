This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-28T22:08:05.912Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
components/
  SignInButton.tsx
context/
  AppContext.tsx
  AuthContext.tsx
  UserContext.tsx
core/
  constants/
    metrics.ts
  types/
    api.ts
    base.ts
  utils/
    formatting.ts
    scoring.ts
features/
  auth/
    components/
      LoginScreen.tsx
      RegisterScreen.tsx
    types/
      auth.ts
  health/
    hooks/
      useHealthData.ts
    services/
      platforms/
        AppleHealthService.ts
        GHealthConnectService.ts
        GoogleHealthService.ts
        MockHealthService.ts
      base.ts
      factory.ts
      NativeHealthConnect.ts
      platform.ts
      types.ts
    types/
      health.ts
  home/
    components/
      GoalCelebration.tsx
      HomeScreen.tsx
      MetricCard.tsx
      MetricModal.tsx
    styles/
      GoalCelebration.styles.ts
      HomeScreen.styles.ts
  leaderboard/
    components/
      LeaderboardScreen.tsx
    styles/
      LeaderboardScreen.styles.ts
    types/
      leaderboard.ts
  profile/
    components/
      ProfileScreen.tsx
    types/
      profile.ts
navigation/
  AppStack.tsx
  AuthStack.tsx
  RootNavigator.tsx
  TabNavigator.tsx
  types.ts
services/
  authService.ts
  storageService.ts
theme/
  index.ts

================================================================
Repository Files
================================================================

================
File: components/SignInButton.tsx
================
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import authService from '../services/authService';

export function SignInButton() {
  const [request, _, promptAsync] = authService.useGoogleAuth();

  const handleSignIn = async () => {
    try {
      const response = await promptAsync();
      if (response?.type === 'success' && response.authentication) {
        await authService.signInWithGoogle(response.authentication.accessToken);
      }
    } catch (error) {
      console.error('Sign in error:', error);
    }
  };

  return (
    <TouchableOpacity 
      onPress={handleSignIn}
      disabled={!request}
      style={{
        backgroundColor: '#4285F4',
        padding: 16,
        borderRadius: 8,
      }}
    >
      <Text style={{ color: 'white', textAlign: 'center' }}>
        Sign in with Google
      </Text>
    </TouchableOpacity>
  );
}

================
File: context/AppContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useColorScheme } from 'react-native';
import { customLightTheme, customDarkTheme, AppTheme } from '../theme';

interface AppContextType {
  theme: AppTheme;
  isDarkMode: boolean;
  isLoading: boolean;
};

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const colorScheme = useColorScheme();
  const [isDarkMode, setIsDarkMode] = useState(colorScheme === 'dark');
  const [theme, setTheme] = useState(isDarkMode ? customDarkTheme : customLightTheme);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeApp = async () => {
      // Defer initialization to next frame to avoid blocking UI
      requestAnimationFrame(async () => {
        try {
          const savedTheme = await AsyncStorage.getItem('theme');
          if (savedTheme) {
            // Ensure state updates happen in next frame
            requestAnimationFrame(() => {
              setIsDarkMode(savedTheme === 'dark');
              setTheme(savedTheme === 'dark' ? customDarkTheme : customLightTheme);
            });
          }
        } catch (error) {
          console.error('Error loading theme:', error);
        } finally {
          setIsLoading(false);
        }
      });
    };

    initializeApp();
  }, []);

  useEffect(() => {
    setTheme(isDarkMode ? customDarkTheme : customLightTheme);
  }, [isDarkMode]);

  const toggleTheme = async () => {
    const newIsDarkMode = !isDarkMode;
    setIsDarkMode(newIsDarkMode);
    setTheme(newIsDarkMode ? customDarkTheme : customLightTheme);
    
    // Defer storage operation to next frame
    requestAnimationFrame(async () => {
      try {
        await AsyncStorage.setItem('theme', newIsDarkMode ? 'dark' : 'light');
      } catch (error) {
        console.error('Error saving theme:', error);
      }
    });
  };

  return (
    <AppContext.Provider value={{ theme, isDarkMode, isLoading }}>
      {children}
    </AppContext.Provider>
  );
};

export const useApp = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

================
File: context/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Google from 'expo-auth-session/providers/google';
import * as WebBrowser from 'expo-web-browser';
import { Platform } from 'react-native';
import Constants from 'expo-constants';

WebBrowser.maybeCompleteAuthSession();

// Types
interface User {
  id: string;
  email: string;
  name?: string;
  photoUrl?: string;
}

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  signInWithGoogle: () => Promise<void>;
  signOut: () => Promise<void>;
}

interface AuthProviderProps {
  children: ReactNode;
}

// Context
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Provider
export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Google OAuth configuration
  const [request, response, promptAsync] = Google.useAuthRequest({
    androidClientId: Constants.expoConfig?.extra?.googleAuth?.androidClientId,
    iosClientId: Constants.expoConfig?.extra?.googleAuth?.iosClientId,
    webClientId: Constants.expoConfig?.extra?.googleAuth?.webClientId,
    clientId: Constants.expoConfig?.extra?.googleAuth?.expoClientId,
    scopes: ['openid', 'profile', 'email'],
  });

  // For development: Set mock user immediately
  useEffect(() => {
    const mockUser: User = {
      id: 'mock-user-id',
      email: 'mock@example.com',
      name: 'Mock User',
      photoUrl: 'https://via.placeholder.com/150',
    };
    setUser(mockUser);
    setIsLoading(false);
  }, []);

  // Mock sign in function for development
  const signInWithGoogle = async () => {
    const mockUser: User = {
      id: 'mock-user-id',
      email: 'mock@example.com',
      name: 'Mock User',
      photoUrl: 'https://via.placeholder.com/150',
    };
    setUser(mockUser);
  };

  const signOut = async () => {
    try {
      setError(null);
      await AsyncStorage.removeItem('user');
      setUser(null);
    } catch (err) {
      console.error('Error signing out:', err);
      setError('Failed to sign out');
    }
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        error,
        signInWithGoogle,
        signOut,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// Hook
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: context/UserContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import { User } from '../services/authService';
import { StorageService } from '../services/storageService';

interface UserContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  isLoading: boolean;
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export function UserProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadUser = async () => {
      try {
        const userData = await StorageService.getUserData();
        if (userData) {
          setUser(userData);
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadUser();
  }, []);

  const updateUser = async (newUser: User | null) => {
    setUser(newUser);
    if (newUser) {
      await StorageService.setUserData(newUser);
    } else {
      await StorageService.clearAll();
    }
  };

  return (
    <UserContext.Provider
      value={{
        user,
        setUser: updateUser,
        isLoading,
      }}
    >
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}

================
File: core/constants/metrics.ts
================
export const HEALTH_METRICS = {
  STEPS: {
    DAILY_GOAL: 10000,
    MIN_HEALTHY: 5000,
    HISTORY_DAYS: 7,  // Number of days to track in history
    START_OF_WEEK: 6  // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
  },
  DISTANCE: {
    DAILY_GOAL: 8.05, // kilometers (approximately 5 miles)
    MIN_HEALTHY: 4.0, // kilometers
    HISTORY_DAYS: 7,
    START_OF_WEEK: 6
  }
};

// Helper function to get the date 6 days ago
export const getCurrentWeekStart = (): Date => {
  const today = new Date();
  const startDate = new Date(today);
  startDate.setDate(today.getDate() - 6);
  startDate.setHours(0, 0, 0, 0);
  return startDate;
};

================
File: core/types/api.ts
================
export interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
  timestamp?: Date;
}

export interface PaginatedResponse<T> extends ApiResponse<T> {
  page: number;
  limit: number;
  total: number;
  hasMore: boolean;
}

================
File: core/types/base.ts
================
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export type Gender = 'male' | 'female' | 'other' | 'prefer-not-to-say';
export type BloodType = 'A+' | 'A-' | 'B+' | 'B-' | 'AB+' | 'AB-' | 'O+' | 'O-';
export type MeasurementSystem = 'metric' | 'imperial';
export type PrivacyLevel = 'private' | 'friends' | 'public';
export type DataSource = 'apple_health' | 'health_connect' | 'manual';
export type SleepQuality = 'poor' | 'fair' | 'good' | 'excellent';

================
File: core/utils/formatting.ts
================
import { MeasurementSystem } from '../types/base';

export const formatDistance = (kilometers: number, system: MeasurementSystem): string => {
  if (system === 'imperial') {
    const miles = kilometers * 0.621371;
    return `${miles.toFixed(2)} mi`;
  }
  return `${kilometers.toFixed(2)} km`;
};

export const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return `${hours}h ${remainingMinutes}m`;
};

export const formatHeartRate = (bpm: number): string => {
  return `${Math.round(bpm)} bpm`;
};

export const formatBloodPressure = (systolic: number, diastolic: number): string => {
  return `${systolic}/${diastolic} mmHg`;
};

export const formatScore = (score: number): string => {
  return `${Math.round(score)}/100`;
};

================
File: core/utils/scoring.ts
================
import { HealthMetrics, HealthScore } from '../../features/health/types/health';
import { HEALTH_METRICS } from '../constants/metrics';

export class HealthScoring {
  static calculateScore(metrics: HealthMetrics): HealthScore {
    const steps = metrics.steps || 0;
    const distance = metrics.distance || 0;
    
    const stepsScore = this.calculateStepsScore(steps);
    const distanceScore = this.calculateDistanceScore(distance);
    const bonusPoints = this.calculateStepsBonusPoints(steps);
    
    // Combine scores and include bonus points
    const overall = Math.min(100, ((stepsScore + distanceScore) / 2) + bonusPoints);

    return {
      overall: Math.round(overall),
      categories: {
        steps: Math.round(stepsScore),
        distance: Math.round(distanceScore)
      },
      dailyVictory: steps >= HEALTH_METRICS.STEPS.DAILY_GOAL,
      bonusPoints: bonusPoints
    };
  }

  private static calculateStepsScore(steps: number): number {
    // Calculate points based on 10 points per 1000 steps
    const pointsPer1000Steps = 10;
    const basePoints = Math.floor(steps / 1000) * pointsPer1000Steps;
    
    // Cap the base points at 100
    return Math.min(100, basePoints);
  }

  private static calculateStepsBonusPoints(steps: number): number {
    // Award 5 bonus points if daily goal is reached
    const { DAILY_GOAL } = HEALTH_METRICS.STEPS;
    return steps >= DAILY_GOAL ? 5 : 0;
  }

  private static calculateDistanceScore(distance: number): number {
    const { DAILY_GOAL } = HEALTH_METRICS.DISTANCE;
    const distanceInKm = distance;
    if (distanceInKm >= DAILY_GOAL) return 100;
    if (distanceInKm <= 0) return 0;
    return Math.min(100, (distanceInKm / DAILY_GOAL) * 100);
  }
}

================
File: features/auth/components/LoginScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { useTheme, TextInput, Button, Text } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { AuthStackParamList } from '../../../navigation/types';
import { useAuth } from '../../../context/AuthContext';

type LoginScreenProps = {
  navigation: StackNavigationProp<AuthStackParamList, 'Login'>;
};

export const LoginScreen: React.FC<LoginScreenProps> = ({ navigation }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [localError, setLocalError] = useState<string | null>(null);
  const theme = useTheme();
  const { signInWithGoogle, error: authError, isLoading } = useAuth();

  const handleLogin = async () => {
    if (!email || !password) {
      setLocalError('Please enter both email and password');
      return;
    }
    setLocalError(null);
    // Email/password login not implemented in this version
    setLocalError('Email/password login is not available. Please use Google Sign-In.');
  };

  const handleGoogleSignIn = async () => {
    setLocalError(null);
    try {
      await signInWithGoogle();
    } catch (err) {
      console.error('Google sign-in error:', err);
      setLocalError('Failed to sign in with Google. Please try again.');
    }
  };

  const error = localError || authError;

  return (
    <View style={styles.container}>
      <Text variant="headlineMedium" style={styles.title}>Welcome Back</Text>

      <TextInput
        label="Email"
        value={email}
        onChangeText={(text) => {
          setEmail(text);
          setLocalError(null);
        }}
        mode="outlined"
        style={styles.input}
        autoCapitalize="none"
        keyboardType="email-address"
        disabled={isLoading}
      />
      
      <TextInput
        label="Password"
        value={password}
        onChangeText={(text) => {
          setPassword(text);
          setLocalError(null);
        }}
        mode="outlined"
        style={styles.input}
        secureTextEntry
        disabled={isLoading}
      />

      {error && (
        <Text variant="bodySmall" style={[styles.error, { color: theme.colors.error }]}>
          {error}
        </Text>
      )}

      <Button
        mode="contained"
        onPress={handleLogin}
        loading={isLoading}
        style={styles.button}
        disabled={isLoading || !email || !password}
      >
        Sign In
      </Button>

      <Button
        mode="outlined"
        onPress={handleGoogleSignIn}
        loading={isLoading}
        style={styles.googleButton}
        disabled={isLoading}
        icon="google"
      >
        Sign in with Google
      </Button>

      <Button
        mode="text"
        onPress={() => navigation.navigate('Register')}
        style={styles.link}
        disabled={isLoading}
      >
        Don't have an account? Register
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 24,
  },
  title: {
    marginBottom: 32,
    textAlign: 'center',
  },
  input: {
    marginBottom: 16,
  },
  button: {
    marginTop: 16,
  },
  googleButton: {
    marginTop: 10,
  },
  error: {
    marginBottom: 16,
    textAlign: 'center',
  },
  link: {
    marginTop: 15,
  },
});

================
File: features/auth/components/RegisterScreen.tsx
================
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { useTheme, Button, Text } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { AuthStackParamList } from '../../../navigation/types';
import { useAuth } from '../../../context/AuthContext';

type RegisterScreenProps = {
  navigation: StackNavigationProp<AuthStackParamList, 'Register'>;
};

export const RegisterScreen: React.FC<RegisterScreenProps> = ({ navigation }) => {
  const [localError, setLocalError] = useState<string | null>(null);
  const theme = useTheme();
  const { signInWithGoogle, error: authError, isLoading } = useAuth();

  const handleGoogleSignIn = async () => {
    setLocalError(null);
    try {
      await signInWithGoogle();
    } catch (err) {
      console.error('Google sign-in error:', err);
      setLocalError('Failed to sign in with Google. Please try again.');
    }
  };

  const error = localError || authError;

  return (
    <View style={styles.container}>
      <Text variant="headlineMedium" style={styles.title}>Create Account</Text>
      
      <Text variant="bodyMedium" style={styles.subtitle}>
        Create an account quickly and easily using your Google account
      </Text>

      {error && (
        <Text variant="bodySmall" style={[styles.error, { color: theme.colors.error }]}>
          {error}
        </Text>
      )}

      <Button
        mode="contained"
        onPress={handleGoogleSignIn}
        loading={isLoading}
        style={styles.googleButton}
        disabled={isLoading}
        icon="google"
      >
        Sign up with Google
      </Button>

      <Button
        mode="text"
        onPress={() => navigation.navigate('Login')}
        style={styles.link}
        disabled={isLoading}
      >
        Already have an account? Sign in
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 24,
  },
  title: {
    marginBottom: 16,
    textAlign: 'center',
  },
  subtitle: {
    textAlign: 'center',
    marginBottom: 32,
    opacity: 0.7,
  },
  googleButton: {
    marginTop: 16,
  },
  error: {
    marginBottom: 16,
    textAlign: 'center',
  },
  link: {
    marginTop: 15,
  },
});

================
File: features/auth/types/auth.ts
================
export type User = {
  id: string;
  email: string;
  displayName?: string;
  lastSignOutAt?: string;
  createdAt?: string;
  updatedAt?: string;
};

export type AuthState = {
  isAuthenticated: boolean;
  user: User | null;
  isLoading: boolean;
  error: string | null;
};

export type AuthContextType = AuthState & {
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string) => Promise<void>;
  signInWithGoogle: () => Promise<void>;
  logout: () => Promise<void>;
};

================
File: features/health/hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { HealthMetrics, WeeklyMetrics } from '../types/health';
import { HealthServiceFactory } from '../services/factory';
import { HealthService } from '../services/types';
import AppleHealthKit from 'react-native-health';
import { getCurrentWeekStart } from '../../../core/constants/metrics';

const { Permissions } = AppleHealthKit.Constants;

const defaultPermissions = {
  permissions: {
    read: [
      Permissions.Steps,
      Permissions.DistanceWalkingRunning,
    ],
    write: [],
  },
};

const useHealthData = (profileId: string) => {
  const [healthService, setHealthService] = useState<HealthService | null>(null);
  const [metrics, setMetrics] = useState<HealthMetrics & WeeklyMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const initialize = useCallback(async () => {
    try {
      const service = await HealthServiceFactory.getService();
      setHealthService(service);
      
      const initialized = await service.initialize(defaultPermissions);
      if (initialized) {
        const permissions = await service.hasPermissions();
        setHasPermission(permissions);
        return permissions;
      }
      return false;
    } catch (err) {
      console.error('Health service initialization error:', err);
      setError('Failed to initialize health service');
      return false;
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions || !healthService) return;

    setLoading(true);
    setError(null);

    try {
      // Wrap HealthKit operations in a background task
      const newMetrics = await new Promise<HealthMetrics & WeeklyMetrics>((resolve, reject) => {
        requestAnimationFrame(async () => {
          try {
            const [metrics, weeklySteps] = await Promise.all([
              healthService.getMetrics(),
              healthService.getWeeklySteps(getCurrentWeekStart())
            ]);
            
            resolve({
              ...metrics,
              weeklySteps,
              weekStartDate: getCurrentWeekStart()
            });
          } catch (error) {
            reject(error);
          }
        });
      });

      setMetrics({
        ...newMetrics,
        profileId,
        weeklySteps: newMetrics.weeklySteps,
        weekStartDate: newMetrics.weekStartDate
      });
    } catch (err) {
      console.error('Error fetching health data:', err);
      setError('Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions, profileId]);

  const refresh = useCallback(async () => {
    await fetchHealthData();
  }, [fetchHealthData]);

  useEffect(() => {
    const setupHealthData = async () => {
      const initialized = await initialize();
      if (initialized) {
        await fetchHealthData();
      }
    };

    setupHealthData();
  }, [initialize, fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    refresh,
    hasPermissions,
  };
};

export default useHealthData;

================
File: features/health/services/platforms/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
} from 'react-native-health';
import { Platform, InteractionManager } from 'react-native';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class AppleHealthService extends BaseHealthService {
  protected source = 'apple_health' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return new Promise((resolve) => {
      // Ensure initialization happens on main thread
      Platform.select({
        ios: () => {
          InteractionManager.runAfterInteractions(() => {
            AppleHealthKit.initHealthKit(config as HealthKitPermissions, (error: string) => {
              // Ensure callback executes on main thread
              requestAnimationFrame(() => {
                resolve(!error);
              });
            });
          });
        },
        default: () => resolve(false),
      })();
    });
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  protected async doHasPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getStepCount(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value);
          });
        });
      });
    });
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getDistanceWalkingRunning(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value / 1000); // Convert to kilometers
          });
        });
      });
    });
  }
}

================
File: features/health/services/platforms/GHealthConnectService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';
import { Platform } from 'react-native';
import NativeHealthConnect from '../NativeHealthConnect';

export class GHealthConnectService extends BaseHealthService {
  protected source = 'health_connect' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    if (Platform.OS !== 'android') return false;

    try {
      const availability = await NativeHealthConnect.isAvailable();
      if (!availability) {
        console.warn('Health Connect is not available on this device');
        return false;
      }
      
      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Health Connect initialization error:', error);
      return false;
    }
  }

  protected async doRequestPermissions(): Promise<boolean> {
    if (!this.initialized) return false;

    try {
      return await NativeHealthConnect.requestPermissions([
        'android.permission.health.READ_STEPS',
        'android.permission.health.READ_DISTANCE'
      ]);
    } catch (error) {
      console.error('Health Connect permission request error:', error);
      return false;
    }
  }

  protected async doHasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    
    try {
      // For now just attempt to read steps as a permissions check
      const now = new Date();
      await this.getDailySteps(now);
      return true;
    } catch (error) {
      return false;
    }
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      const steps = await NativeHealthConnect.getDailySteps(
        startTime.getTime(),
        endTime.getTime()
      );
      return steps || 0; // Return 0 if no data available
    } catch (error) {
      console.error('Error reading steps from Health Connect:', error);
      return 0; // Return 0 on error
    }
  }

  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      return await NativeHealthConnect.getDailyDistance(
        startTime.getTime(),
        endTime.getTime()
      );
    } catch (error) {
      console.error('Error reading distance from Health Connect:', error);
      throw error;
    }
  }
}

================
File: features/health/services/platforms/GoogleHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class GoogleHealthService extends BaseHealthService {
  protected source = 'google_fit' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    // TODO: Implement Google Fit initialization
    return false;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions request
    return false;
  }

  protected async doHasPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions check
    return false;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }
}

================
File: features/health/services/platforms/MockHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class MockHealthService extends BaseHealthService {
  protected source = 'manual' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return true;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    // Return a random number of steps between 5000 and 15000
    return Math.floor(Math.random() * (15000 - 5000 + 1)) + 5000;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    // Return a random distance between 3 and 10 kilometers
    return Number((Math.random() * (10 - 3) + 3).toFixed(2));
  }
}

================
File: features/health/services/base.ts
================
import { HealthService, HealthServiceConfig } from './types';
import { HealthMetrics } from '../types/health';
import { HealthScoring } from '../../../core/utils/scoring';
import { DataSource } from '../../../core/types/base';

export abstract class BaseHealthService implements HealthService {
  protected initialized = false;
  protected abstract source: DataSource;

  async initialize(config: HealthServiceConfig): Promise<boolean> {
    if (this.initialized) return true;
    const success = await this.doInitialize(config);
    this.initialized = success;
    return success;
  }

  protected abstract doInitialize(config: HealthServiceConfig): Promise<boolean>;

  async requestPermissions(): Promise<boolean> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    return this.doRequestPermissions();
  }

  protected abstract doRequestPermissions(): Promise<boolean>;

  async hasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    return this.doHasPermissions();
  }

  protected abstract doHasPermissions(): Promise<boolean>;

  async getMetrics(date: Date = new Date()): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }

    const [steps, distance] = await Promise.all([
      this.getDailySteps(date),
      this.getDailyDistance(date),
    ]);

    const now = new Date();
    const id = `metrics_${now.getTime()}`;

    const metrics: HealthMetrics = {
      id,
      profileId: '', // Set from the calling context
      date: date.toISOString(),
      steps,
      distance,
      score: 0,
      source: this.source,
      createdAt: now,
      updatedAt: now,
    };

    const score = HealthScoring.calculateScore(metrics);
    metrics.score = score.overall;

    return metrics;
  }

  abstract getDailySteps(date?: Date): Promise<number>;
  abstract getDailyDistance(date?: Date): Promise<number>;
  
  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    
    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }
}

================
File: features/health/services/factory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './types';
import { AppleHealthService } from './platforms/AppleHealthService';
import { GHealthConnectService } from './platforms/GHealthConnectService';
import { MockHealthService } from './platforms/MockHealthService';
import { getCurrentPlatform } from './platform';

export class HealthServiceFactory {
  static async getService(): Promise<HealthService> {
    const currentPlatform = await getCurrentPlatform();
    
    switch (currentPlatform.id) {
      case 'apple_health':
        return new AppleHealthService();
      case 'health_connect':
        return new GHealthConnectService();
      default:
        return new MockHealthService();
    }
  }
}

================
File: features/health/services/NativeHealthConnect.ts
================
import { NativeModules } from 'react-native';

const { HealthConnectModule } = NativeModules;

if (!HealthConnectModule) {
  throw new Error(
    'HealthConnectModule is not available. Did you properly link the native module?'
  );
}

interface NativeHealthConnectInterface {
  isAvailable(): Promise<boolean>;
  requestPermissions(permissions: string[]): Promise<boolean>;
  getDailySteps(startTime: number, endTime: number): Promise<number>;
  getDailyDistance(startTime: number, endTime: number): Promise<number>;
}

const NativeHealthConnect: NativeHealthConnectInterface = {
  isAvailable: HealthConnectModule.isAvailable,
  requestPermissions: HealthConnectModule.requestPermissions,
  getDailySteps: HealthConnectModule.getDailySteps,
  getDailyDistance: HealthConnectModule.getDailyDistance,
};

export default NativeHealthConnect;

================
File: features/health/services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

const appleHealthPlatform: HealthPlatform = {
  id: 'apple_health',
  name: 'Apple Health',
  version: '1.0.0',
  type: 'apple_health'
};

const healthConnectPlatform: HealthPlatform = {
  id: 'health_connect',
  name: 'Health Connect',
  version: '1.0.0',
  type: 'health_connect'
};

const manualPlatform: HealthPlatform = {
  id: 'manual',
  name: 'Manual Entry',
  version: '1.0.0',
  type: 'manual'
};

declare const HealthConnectClient: {
  isAvailable(): Promise<boolean>;
};

export const getCurrentPlatform = async (): Promise<HealthPlatform> => {
  if (Platform.OS === 'ios') {
    return appleHealthPlatform;
  }
  
  if (Platform.OS === 'android') {
    try {
      const isHealthConnectAvailable = await HealthConnectClient.isAvailable();
      if (isHealthConnectAvailable) {
        return healthConnectPlatform;
      }
    } catch (error) {
      console.warn('Error checking Health Connect availability:', error);
    }
    return manualPlatform;
  }
  
  return manualPlatform;
};

================
File: features/health/services/types.ts
================
import { HealthMetrics } from '../types/health';

export interface HealthServiceConfig {
  permissions: {
    read: string[];
    write: string[];
  };
  options?: Record<string, any>;
}

export interface HealthService {
  initialize(config: HealthServiceConfig): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  hasPermissions(): Promise<boolean>;
  getMetrics(date?: Date): Promise<HealthMetrics>;
  getDailySteps(date?: Date): Promise<number>;
  getDailyDistance(date?: Date): Promise<number>;
  getWeeklySteps(startDate: Date): Promise<number[]>;
}

================
File: features/health/types/health.ts
================
import { DataSource } from '../../../core/types/base';

export interface HealthScore {
  overall: number;
  categories: {
    steps: number;
    distance: number;
  };
  dailyVictory: boolean;
  bonusPoints: number;
}

export interface HealthMetrics {
  id: string;
  profileId: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
  source: DataSource;
  createdAt: Date;
  updatedAt: Date;
}

export interface WeeklyMetrics {
  weeklySteps: number[];
  weekStartDate: Date;
}

export type MetricType = 'steps' | 'distance' | 'score';

export interface HealthState {
  isInitialized: boolean;
  hasPermissions: boolean;
  isLoading: boolean;
  error: string | null;
  metrics: HealthMetrics | null;
}

================
File: features/home/components/GoalCelebration.tsx
================
import React, { useEffect } from 'react';
import { Modal, View, Animated, Share, Platform } from 'react-native';
import { useStyles } from '../styles/GoalCelebration.styles';
import { Surface, Text, useTheme, Button } from 'react-native-paper';
import { FontAwesome } from '@expo/vector-icons';
interface GoalCelebrationProps {
  visible: boolean;
  onClose: () => void;
  bonusPoints: number;
}

const GoalCelebration: React.FC<GoalCelebrationProps> = ({
  visible,
  onClose,
  bonusPoints,
}) => {
  const styles = useStyles();
  const theme = useTheme();
  const scale = new Animated.Value(0.5);
  const opacity = new Animated.Value(0);

  useEffect(() => {
    if (visible) {
      // Reset animation values
      scale.setValue(0.5);
      opacity.setValue(0);

      // Entrance animation
      Animated.parallel([
        Animated.spring(scale, {
          toValue: 1,
          useNativeDriver: true,
          damping: 15,
          stiffness: 150,
        }),
        Animated.timing(opacity, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start();

    }
  }, [visible, scale, opacity, onClose]);

  if (!visible) return null;

  const handleShare = async (platform: string) => {
    const message = "I just reached my daily step goal! ðŸŽ‰ Join me on my fitness journey!";
    const url = "https://yourapp.com/signup";
    
    try {
      if (Platform.OS === 'web') {
        // Web-specific sharing
        let shareUrl = '';
        switch (platform) {
          case 'facebook':
            shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}&quote=${encodeURIComponent(message)}`;
            break;
          case 'twitter':
            shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}&url=${encodeURIComponent(url)}`;
            break;
          case 'instagram':
            shareUrl = 'https://instagram.com';
            break;
          case 'whatsapp':
            shareUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(message)} ${encodeURIComponent(url)}`;
            break;
        }
        window.open(shareUrl, '_blank');
      } else {
        // Native sharing
        await Share.share({
          message: `${message}\n${url}`,
          url: url, // iOS only
          title: 'Share Goal Achievement',
        });
      }
      
      // Close celebration after successful share
      Animated.parallel([
        Animated.spring(scale, {
          toValue: 1.2,
          useNativeDriver: true,
        }),
        Animated.timing(opacity, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
      ]).start(() => {
        onClose();
      });
    } catch (error) {
      console.error('Error sharing:', error);
    }
  };

  return (
    <Modal transparent visible={visible} onRequestClose={onClose}>
      <View style={styles.container}>
        <View style={styles.backdrop} onTouchEnd={onClose} />
        <Animated.View
          style={[
            styles.contentContainer,
            {
              transform: [{ scale }],
              opacity,
            },
          ]}
        >
          <Surface
            style={[
              styles.surface,
              {
                backgroundColor: theme.dark
                  ? theme.colors.surfaceVariant
                  : theme.colors.surface,
              },
            ]}
          >
            <View style={styles.starsContainer}>
              {[...Array(3)].map((_, i) => (
                <Animated.View
                  key={i}
                  style={[
                    styles.starContainer,
                    {
                      transform: [
                        {
                          translateY: new Animated.Value(0).interpolate({
                            inputRange: [0, 1],
                            outputRange: [0, -10],
                          }),
                        },
                      ],
                    },
                  ]}
                >
                  <View style={[styles.star, { marginHorizontal: 4 }]}>
                    <FontAwesome
                      name="star"
                      size={32}
                      color={theme.colors.primary}
                    />
                  </View>
                </Animated.View>
              ))}
            </View>

            <Text
              variant="headlineMedium"
              style={[styles.title, { color: theme.colors.onSurface }]}
            >
              Congratulations!
            </Text>

            <Text
              variant="titleMedium"
              style={[styles.subtitle, { color: theme.colors.onSurface }]}
            >
              You've reached your daily step goal!
            </Text>

            <Text
              variant="titleLarge"
              style={[styles.points, { color: theme.colors.primary }]}
            >
              +{bonusPoints} Bonus Points Earned!
            </Text>

            <Text
              variant="bodyMedium"
              style={[styles.sharePrompt, { color: theme.colors.onSurfaceVariant }]}
            >
              Share your achievement to continue
            </Text>

            <View style={styles.shareButtonsContainer}>
              <Button
                mode="contained"
                onPress={() => handleShare('facebook')}
                style={[styles.shareButton, { backgroundColor: '#1877F2' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="facebook" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('twitter')}
                style={[styles.shareButton, { backgroundColor: '#1DA1F2' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="twitter" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('instagram')}
                style={[styles.shareButton, { backgroundColor: '#E4405F' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="instagram" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
              <Button
                mode="contained"
                onPress={() => handleShare('whatsapp')}
                style={[styles.shareButton, { backgroundColor: '#25D366' }]}
                icon={() => (
                  <View style={{ width: '100%', alignItems: 'center' }}>
                  <FontAwesome name="whatsapp" size={30} color="white" />
                  </View>
                )}
                contentStyle={styles.buttonContent}
              >
                {''}
              </Button>
            </View>
          </Surface>
        </Animated.View>
      </View>
    </Modal>
  );
};

export default GoalCelebration;

================
File: features/home/components/HomeScreen.tsx
================
import React, { useState, useEffect } from 'react';
import { View, ScrollView, RefreshControl } from 'react-native';
import { useTheme, Text, Surface, ActivityIndicator, IconButton } from 'react-native-paper';
import { StatusBar } from 'expo-status-bar';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import useHealthData from '../../health/hooks/useHealthData';
import { formatDistance, formatScore } from '../../../core/utils/formatting';
import { MetricCard } from './MetricCard';
import { MetricModal } from './MetricModal';
import { HealthMetrics, WeeklyMetrics } from '../../health/types/health';
import { TabParamList } from '../../../navigation/types';
import { MeasurementSystem } from '../../../core/types/base';
import GoalCelebration from './GoalCelebration';
import { useStyles } from '../styles/HomeScreen.styles';

// TODO: Replace with actual user profile management
const MOCK_PROFILE_ID = 'test_user_1';
// TODO: Make this configurable per user's preference
const DEFAULT_MEASUREMENT_SYSTEM: MeasurementSystem = 'imperial';

type MetricType = 'steps' | 'distance' | 'score';

interface ModalData {
  type: MetricType;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
    startDate?: Date;
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

type NavigationProp = NativeStackNavigationProp<TabParamList, 'Home'>;

export const HomeScreen: React.FC = () => {
  const theme = useTheme();
  const styles = useStyles();
  const navigation = useNavigation<NavigationProp>();
  const { metrics, loading, error, refresh } = useHealthData(MOCK_PROFILE_ID);
  const [refreshing, setRefreshing] = React.useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedMetric, setSelectedMetric] = useState<ModalData | null>(null);
  const [showCelebration, setShowCelebration] = useState(false);
  const [previousSteps, setPreviousSteps] = useState(0);

  useEffect(() => {
    if (metrics?.steps && metrics.steps >= 10000 && previousSteps < 10000) {
      setShowCelebration(true);
    }
    if (metrics?.steps) {
      setPreviousSteps(metrics.steps);
    }
  }, [metrics?.steps]);

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    await refresh();
    setRefreshing(false);
  }, [refresh]);

  const handleLeaderboardPress = () => {
    navigation.navigate('Leaderboard');
  };

  const handleMetricPress = (type: MetricType, metrics: HealthMetrics & WeeklyMetrics) => {
    let modalData: ModalData = {
      type,
      title: type.charAt(0).toUpperCase() + type.slice(1),
      value: type === 'distance' ? formatDistance(metrics[type], DEFAULT_MEASUREMENT_SYSTEM) : metrics[type].toString(),
      data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        values: type === 'steps' ? metrics.weeklySteps : [0, 0, 0, 0, 0, 0, metrics[type]],
        startDate: type === 'steps' ? metrics.weekStartDate : undefined
      },
    };

    setSelectedMetric(modalData);
    setModalVisible(true);
  };

  if (loading && !refreshing) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </Surface>
    );
  }

  if (error) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <Text variant="titleMedium" style={styles.errorText}>{error}</Text>
        <IconButton icon="refresh" onPress={refresh} />
      </Surface>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar style={theme.dark ? 'light' : 'dark'} />
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* <View style={styles.header}>
          <Text variant="headlineMedium" style={styles.title}>
            Health Dashboard
          </Text>
          <IconButton
            icon="trophy"
            mode="contained"
            onPress={handleLeaderboardPress}
            style={styles.leaderboardButton}
          />
        </View> */}

        <View style={styles.metricsContainer}>
          <MetricCard
            title="Steps"
            value={metrics?.steps?.toLocaleString() || '0'}
            icon="walk"
            metricType="steps"
            onPress={() => metrics && handleMetricPress('steps', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Distance"
            value={formatDistance(metrics?.distance || 0, DEFAULT_MEASUREMENT_SYSTEM)}
            icon="map-marker-distance"
            metricType="distance"
            onPress={() => metrics && handleMetricPress('distance', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Score"
            value={formatScore(metrics?.score || 0)}
            icon="star"
            metricType="score"
            onPress={() => metrics && handleMetricPress('score', metrics)}
            loading={loading}
            error={error}
          />
        </View>

        {selectedMetric && (
          <MetricModal
            visible={modalVisible}
            onClose={() => setModalVisible(false)}
            title={selectedMetric?.title || ''}
            value={selectedMetric?.value || ''}
            data={selectedMetric?.data}
            additionalInfo={selectedMetric?.additionalInfo}
          />
        )}
      </ScrollView>

      <GoalCelebration 
        visible={showCelebration}
        onClose={() => setShowCelebration(false)}
        bonusPoints={5}
      />
    </View>
  );
};

================
File: features/home/components/MetricCard.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Surface, Text, TouchableRipple, useTheme, ActivityIndicator } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { getMetricColor, MetricColorKey } from '../../../theme';
import { getCurrentWeekStart } from '../../../core/constants/metrics';

interface MetricCardProps {
  title: string;
  value: string | number;
  icon: keyof typeof MaterialCommunityIcons.glyphMap;
  metricType: MetricColorKey;
  onPress?: (startDate?: Date) => void;
  loading?: boolean;
  error?: string | null;
}

export const MetricCard: React.FC<MetricCardProps> = ({
  title,
  value,
  icon,
  metricType,
  onPress,
  loading,
  error,
}) => {
  const theme = useTheme();
  const metricColor = getMetricColor(metricType);
  const surfaceColor = theme.colors.surface;
  const borderColor = theme.colors.secondary;
  const borderWidth = 2;
  
  const handlePress = () => {
    if (onPress) {
      onPress(getCurrentWeekStart());
    }
  };

  const renderContent = () => {
    if (loading) {
      return <ActivityIndicator size="small" color={metricColor} />;
    }

    if (error) {
      return <Text style={[styles.errorText, { color: theme.colors.error }]}>{error}</Text>;
    }

    return (
      <>
        <MaterialCommunityIcons name={icon} size={24} color={metricColor} />
        <Text variant="titleLarge" style={[styles.value, { color: theme.colors.onSurface }]}>
          {value}
        </Text>
        <Text variant="labelMedium" style={[styles.title, { color: theme.colors.onSurfaceVariant }]}>
          {title}
        </Text>
      </>
    );
  };

  return (
    <Surface
      style={[
        styles.container,
        {
          backgroundColor: surfaceColor,
          borderColor: borderColor,
          shadowColor: metricColor,
        },
      ]}
      elevation={2}
    >
      <View style={styles.innerContainer}>
        <TouchableRipple
          onPress={handlePress}
          style={styles.touchable}
          rippleColor={metricColor}
          disabled={loading || !!error}
        >
          <>{renderContent()}</>
        </TouchableRipple>
      </View>
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: 8,
    borderRadius: 16,
    minHeight: 120,
    borderWidth: 2,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  innerContainer: {
    flex: 1,
    overflow: 'hidden',
    borderRadius: 12,
  },
  touchable: {
    flex: 1,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  value: {
    marginTop: 8,
    fontWeight: '600',
  },
  title: {
    marginTop: 4,
  },
  errorText: {
    textAlign: 'center',
    padding: 8,
  },
});

================
File: features/home/components/MetricModal.tsx
================
import React from 'react';
import { StyleSheet, View, Dimensions } from 'react-native';
import { Modal, Portal, Text, IconButton, Surface, useTheme, MD3Theme } from 'react-native-paper';
import { LineChart } from 'react-native-chart-kit';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

interface MetricModalProps {
  visible: boolean;
  onClose: () => void;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
    startDate?: Date;
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

const formatDateLabel = (date: Date): string => {
  const today = new Date();
  const isToday = date.toDateString() === today.toDateString();
  return isToday ? 'Today' : date.toLocaleDateString('en-US', { weekday: 'short' });
};

const generateWeekLabels = (startDate: Date): string[] => {
  const labels: string[] = [];
  const currentDate = new Date(startDate);
  
  // Generate labels for the past 6 days plus today
  for (let i = 0; i < 7; i++) {
    labels.push(formatDateLabel(currentDate));
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return labels;
};

export const MetricModal: React.FC<MetricModalProps> = ({
  visible,
  onClose,
  title,
  value,
  data,
  additionalInfo,
}) => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();

  const styles = StyleSheet.create({
    modalContainer: {
      margin: 0,
      justifyContent: 'flex-end',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalContent: {
      padding: 24,
      borderTopLeftRadius: 28,
      borderTopRightRadius: 28,
      borderWidth: 2,
      borderColor: theme.colors.secondary,
    },
    closeButton: {
      position: 'absolute',
      right: 8,
      top: 8,
    },
    modalTitle: {
      marginTop: 8,
      marginBottom: 4,
    },
    modalValue: {
      marginBottom: 16,
    },
    chartContainer: {
      alignItems: 'center',
      marginVertical: 16,
    },
    additionalInfoContainer: {
      marginTop: 16,
      gap: 12,
    },
    infoRow: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
  });

  const chartConfig = {
    backgroundColor: theme.colors.surface,
    backgroundGradientFrom: theme.colors.primaryContainer,
    backgroundGradientTo: theme.colors.surface,
    decimalPlaces: 0,
    color: (opacity = 1) => `rgba(32, 178, 170, ${opacity})`, // Light sea green
    labelColor: (opacity = 1) => theme.colors.onSurface,
    style: {
      borderRadius: 16,
    },
    propsForDots: {
      r: '6',
      strokeWidth: '2',
      stroke: '#20B2AA', // Light sea green
      fill: theme.colors.surface,
    },
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onClose}
        contentContainerStyle={[
          styles.modalContainer,
          { paddingBottom: insets.bottom },
          { backgroundColor: theme.colors.surface }
        ]}
      >
        <Surface style={styles.modalContent} elevation={0}>
          <IconButton
            icon="close"
            size={24}
            onPress={onClose}
            style={styles.closeButton}
          />

          <Text variant="headlineMedium" style={styles.modalTitle}>
            {title}
          </Text>
          <Text variant="displaySmall" style={[styles.modalValue, { color: theme.colors.primary }]}>
            {value}
          </Text>

          {data && data.values.length > 0 && (
            <View style={styles.chartContainer}>
              <LineChart
                data={{
                  labels: data.startDate ? generateWeekLabels(data.startDate) : data.labels,
                  datasets: [{ data: data.values }],
                }}
                width={Dimensions.get('window').width - 48}
                height={220}
                chartConfig={chartConfig}
                bezier
                style={{
                  marginVertical: 8,
                  borderRadius: 16,
                }}
              />
            </View>
          )}

          {additionalInfo && additionalInfo.length > 0 && (
            <Surface style={styles.additionalInfoContainer} elevation={0}>
              {additionalInfo.map((info, index) => (
                <View key={index} style={styles.infoRow}>
                  <Text variant="labelLarge" style={{ color: theme.colors.onSurfaceVariant }}>
                    {info.label}
                  </Text>
                  <Text variant="bodyLarge" style={{ color: theme.colors.onSurface }}>
                    {info.value}
                  </Text>
                </View>
              ))}
            </Surface>
          )}
        </Surface>
      </Modal>
    </Portal>
  );
};

================
File: features/home/styles/GoalCelebration.styles.ts
================
import { StyleSheet } from 'react-native';
import { MD3Theme, useTheme } from 'react-native-paper';

const createStyles = (theme: MD3Theme) => StyleSheet.create({
    sharePrompt: {
        marginTop: 16,
        marginBottom: 8,
        textAlign: 'center',
        color: theme.colors.onSurface,
    },
    shareButtonsContainer: {
        flexDirection: 'row',
        justifyContent: 'center',
        alignItems: 'center',
        marginTop: 24,
        width: '100%',
        gap: 16,
    },
    shareButton: {
        width: 60,
        height: 60,
        borderRadius: 20,
        justifyContent: 'center',
        alignItems: 'center',
        alignSelf: 'center',
        backgroundColor: theme.colors.primaryContainer,
    },
    buttonContent: {
        height: '100%',
        width: '100%',
        alignItems: 'center',
        justifyContent: 'center',
        flexDirection: 'row',
        marginLeft: 15,
    },
    container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    backdrop: {
        ...StyleSheet.absoluteFillObject,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    contentContainer: {
        width: '80%',
        maxWidth: 400,
        alignItems: 'center',
    },
    surface: {
        padding: 24,
        borderRadius: 16,
        alignItems: 'center',
        elevation: 4,
        width: '100%',
        backgroundColor: theme.colors.surface,
        borderColor: theme.colors.surfaceVariant,
        borderWidth: 1,
    },
    starsContainer: {
        flexDirection: 'row',
        marginBottom: 16,
        justifyContent: 'center',
    },
    starContainer: {
        padding: 4,
    },
    title: {
        fontWeight: 'bold',
        textAlign: 'center',
        marginBottom: 8,
        color: theme.colors.onSurface,
    },
    subtitle: {
        textAlign: 'center',
        marginBottom: 16,
        color: theme.colors.onSurfaceVariant,
    },
    points: {
        fontWeight: 'bold',
        textAlign: 'center',
        color: theme.colors.primary,
    },
    star: {
        width: 32,
        height: 32,
        justifyContent: 'center',
        alignItems: 'center',
        color: theme.colors.primary,
    },
    starIcon: {
        fontSize: 32,
        lineHeight: 32,
        color: theme.colors.primary,
    },
});

export const useStyles = () => {
    const theme = useTheme();
    return createStyles(theme);
};

================
File: features/home/styles/HomeScreen.styles.ts
================
import { StyleSheet } from 'react-native';
import { MD3Theme, useTheme } from 'react-native-paper';

const createStyles = (theme: MD3Theme) => StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#20B2AA',
  },
  content: {
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    marginBottom: 16,
    color: theme.colors.error,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 16,
    
    elevation: 2,
    shadowColor: theme.colors.primary,
    shadowOffset: {
      width: 0,
      height: 2,
    },

    
  },
  title: {
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  leaderboardButton: {
    margin: 0,
  },
  metricsContainer: {
    width: '100%',
    alignItems: 'stretch',
    gap: 16,
    paddingHorizontal: 8,
  },
  scrollView: {
    flex: 1,
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export const useStyles = () => {
  const theme = useTheme();
  return createStyles(theme);
};

================
File: features/leaderboard/components/LeaderboardScreen.tsx
================
import React from 'react';
import { View, ScrollView } from 'react-native';
import { Surface, Text, useTheme, Avatar, Divider, IconButton } from 'react-native-paper';
import { formatScore } from '../../../core/utils/formatting';
import { DUMMY_DATA, LeaderboardItemProps, ExtendedTheme } from '../types/leaderboard';
import { useStyles } from '../styles/LeaderboardScreen.styles';

const LeaderboardItem: React.FC<LeaderboardItemProps> = ({ entry, isUser }) => {
  const theme = useTheme<ExtendedTheme>();
  const styles = useStyles();
  const [expanded, setExpanded] = React.useState(false);

  // Add null check for entry
  if (!entry) {
    return null;
  }
  
  return (
    <Surface 
      style={[
        styles.itemContainer, 
        isUser && { backgroundColor: theme.colors.primaryContainer }
      ]}
    >
      <View style={styles.mainContent}>
        <View style={styles.rankContainer}>
          <Text style={[styles.rank, { color: theme.colors.primary }]}>{entry.rank}</Text>
        </View>
        <View style={styles.userInfo}>
          {entry.avatarUrl ? (
            <Avatar.Image 
              size={40} 
              source={{ uri: entry.avatarUrl }} 
            />
          ) : (
            <Avatar.Text
              size={40}
              label={entry.name.charAt(0)}
              color={theme.colors.onPrimary}
              style={{ backgroundColor: theme.colors.primary }}
            />
          )}
          <Text style={[styles.name, { marginLeft: 12, color: theme.colors.onSurface }]}>
            {entry.name}
          </Text>
        </View>
        <View style={styles.scoreContainer}>
          <Text style={[styles.score, { color: theme.metrics.score }]}>
            {formatScore(entry.score.overall)}
          </Text>
          <IconButton
            icon={expanded ? 'chevron-up' : 'chevron-down'}
            size={24}
            onPress={() => setExpanded(!expanded)}
            iconColor={theme.colors.primary}
          />
        </View>
      </View>
      
      {expanded && (
        <View style={styles.detailsContainer}>
          <View style={styles.metricRow}>
            <Text style={[styles.metricLabel, { color: theme.colors.onSurfaceVariant }]}>
              Steps
            </Text>
            <Text style={[styles.metricValue, { color: theme.metrics.steps }]}>
              {entry.metrics.steps.toLocaleString()} ({entry.score.categories.steps}pts)
            </Text>
          </View>
          <View style={styles.metricRow}>
            <Text style={[styles.metricLabel, { color: theme.colors.onSurfaceVariant }]}>
              Distance
            </Text>
            <Text style={[styles.metricValue, { color: theme.metrics.distance }]}>
              {entry.metrics.distance.toFixed(1)}km ({entry.score.categories.distance}pts)
            </Text>
          </View>
          <View style={styles.metricRow}>
            <Text style={[styles.metricLabel, { color: theme.colors.onSurfaceVariant }]}>
              Bonus Points
            </Text>
            <Text style={[styles.metricValue, { color: theme.colors.secondary }]}>
              +{entry.score.bonusPoints}
            </Text>
          </View>
        </View>
      )}
    </Surface>
  );
};

export const LeaderboardScreen: React.FC = () => {
  const theme = useTheme<ExtendedTheme>();
  const styles = useStyles();

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <Surface style={[styles.headerContainer, { backgroundColor: theme.colors.surface }]}>
        <Text variant="headlineMedium" style={[styles.title, { color: theme.colors.onSurface }]}>
          Leaderboard
        </Text>
        <Text variant="bodyMedium" style={{ color: theme.colors.onSurfaceVariant }}>
          Top Health Champions
        </Text>
      </Surface>
      
      <ScrollView style={styles.scrollView}>
        {(DUMMY_DATA || []).map((entry) => entry && (
          <React.Fragment key={entry.id}>
            <LeaderboardItem
              entry={entry}
              isUser={entry.name === 'You'}
            />
            <Divider />
          </React.Fragment>
        ))}
      </ScrollView>
    </View>
  );
};

================
File: features/leaderboard/styles/LeaderboardScreen.styles.ts
================
import { StyleSheet } from 'react-native';
import { MD3Theme, useTheme } from 'react-native-paper';
import { ExtendedTheme } from '../types/leaderboard';

const createStyles = (theme: ExtendedTheme) => StyleSheet.create({
  container: {
    flex: 1,
  },
  headerContainer: {
    padding: 16,
    alignItems: 'center',
    elevation: 2,
  },
  title: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  scrollView: {
    flex: 1,
  },
  itemContainer: {
    padding: 16,
  },
  mainContent: {
    flexDirection: 'row',
    alignItems: 'center',
    height: 60,
  },
  rankContainer: {
    width: 40,
    alignItems: 'center',
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  userInfo: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 12,
  },
  name: {
    fontSize: 16,
    fontWeight: '500',
  },
  scoreContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 'auto',
  },
  score: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  detailsContainer: {
    marginTop: 8,
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: 'rgba(0,0,0,0.1)',
  },
  metricRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginVertical: 4,
  },
  metricLabel: {
    fontSize: 14,
  },
  metricValue: {
    fontSize: 14,
    fontWeight: '500',
  },
});

export const useStyles = () => {
  const theme = useTheme<ExtendedTheme>();
  return createStyles(theme);
};

================
File: features/leaderboard/types/leaderboard.ts
================
import { MD3Theme } from 'react-native-paper/lib/typescript/types';

export interface ExtendedTheme extends MD3Theme {
  metrics: {
    steps: string;
    distance: string;
    score: string;
    calories: string;
    sleep: string;
  };
}

export interface LeaderboardEntry {
  id: string;
  name: string;
  avatarUrl: string;
  metrics: {
    steps: number;
    distance: number;
  };
  score: {
    overall: number;
    categories: {
      steps: number;
      distance: number;
    };
    bonusPoints: number;
  };
  rank: number;
}

export interface LeaderboardItemProps {
  entry: LeaderboardEntry;
  isUser: boolean;
}

// Enhanced dummy data with realistic metrics and scores
export const DUMMY_DATA: LeaderboardEntry[] = [
  {
    id: '1',
    name: 'You',
    avatarUrl: 'https://i.pravatar.cc/150?img=68',
    metrics: { steps: 12000, distance: 8.5 },
    score: {
      overall: 95,
      categories: { steps: 90, distance: 95 },
      bonusPoints: 5
    },
    rank: 1
  },
  {
    id: '2',
    name: 'Sarah Johnson',
    avatarUrl: 'https://i.pravatar.cc/150?img=47',
    metrics: { steps: 11500, distance: 8.2 },
    score: {
      overall: 92,
      categories: { steps: 85, distance: 94 },
      bonusPoints: 5
    },
    rank: 2
  },
  {
    id: '3',
    name: 'Mike Chen',
    avatarUrl: 'https://i.pravatar.cc/150?img=11',
    metrics: { steps: 10800, distance: 7.8 },
    score: {
      overall: 88,
      categories: { steps: 80, distance: 91 },
      bonusPoints: 5
    },
    rank: 3
  },
  {
    id: '4',
    name: 'Emma Wilson',
    avatarUrl: 'https://i.pravatar.cc/150?img=23',
    metrics: { steps: 9500, distance: 7.2 },
    score: {
      overall: 82,
      categories: { steps: 75, distance: 84 },
      bonusPoints: 5
    },
    rank: 4
  },
  {
    id: '5',
    name: 'James Smith',
    avatarUrl: 'https://i.pravatar.cc/150?img=3',
    metrics: { steps: 8800, distance: 6.5 },
    score: {
      overall: 76,
      categories: { steps: 70, distance: 77 },
      bonusPoints: 5
    },
    rank: 5
  },
  {
    id: '6',
    name: 'Lisa Brown',
    avatarUrl: 'https://i.pravatar.cc/150?img=32',
    metrics: { steps: 7500, distance: 5.8 },
    score: {
      overall: 70,
      categories: { steps: 65, distance: 70 },
      bonusPoints: 5
    },
    rank: 6
  },
  {
    id: '7',
    name: 'David Lee',
    avatarUrl: 'https://i.pravatar.cc/150?img=15',
    metrics: { steps: 6800, distance: 5.2 },
    score: {
      overall: 65,
      categories: { steps: 60, distance: 65 },
      bonusPoints: 5
    },
    rank: 7
  },
  {
    id: '8',
    name: 'Anna Garcia',
    avatarUrl: 'https://i.pravatar.cc/150?img=44',
    metrics: { steps: 6200, distance: 4.8 },
    score: {
      overall: 60,
      categories: { steps: 55, distance: 60 },
      bonusPoints: 5
    },
    rank: 8
  },
  {
    id: '9',
    name: 'Tom Wilson',
    avatarUrl: 'https://i.pravatar.cc/150?img=12',
    metrics: { steps: 5500, distance: 4.2 },
    score: {
      overall: 55,
      categories: { steps: 50, distance: 55 },
      bonusPoints: 5
    },
    rank: 9
  },
  {
    id: '10',
    name: 'Rachel Kim',
    avatarUrl: 'https://i.pravatar.cc/150?img=41',
    metrics: { steps: 5000, distance: 3.8 },
    score: {
      overall: 50,
      categories: { steps: 45, distance: 50 },
      bonusPoints: 5
    },
    rank: 10
  },
];

================
File: features/profile/components/ProfileScreen.tsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Button, Avatar, useTheme, HelperText } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { useAuth } from '../../../context/AuthContext';
import { User } from '../../../services/authService';

type RootStackParamList = {
  Profile: undefined;
  Settings: undefined;
  Login: undefined;
};

type ProfileScreenProps = {
  navigation: StackNavigationProp<RootStackParamList, 'Profile'>;
};

export const ProfileScreen: React.FC<ProfileScreenProps> = ({ navigation }) => {
  const paperTheme = useTheme();
  const { user, signOut, isLoading } = useAuth();
  const [displayName, setDisplayName] = useState('');
  const [editMode, setEditMode] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [updateLoading, setUpdateLoading] = useState(false);

  useEffect(() => {
    setDisplayName(user?.name || '');
  }, [user]);

  const handleLogout = useCallback(async () => {
    try {
      await signOut();
    } catch (err) {
      console.error('[ProfileScreen] Logout error:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
    }
  }, [signOut]);

  const handleProfileUpdate = useCallback(async () => {
    if (!displayName.trim()) {
      setError('Display name cannot be empty');
      return;
    }
    
    try {
      setUpdateLoading(true);
      setError(null);
      // TODO: Implement profile update
      setEditMode(false);
    } catch (err) {
      console.error('[ProfileScreen] Profile update error:', err);
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setUpdateLoading(false);
    }
  }, [displayName]);

  return (
    <View style={[styles.container, { backgroundColor: paperTheme.colors.background }]}>
      <ScrollView style={styles.content}>
        <View style={styles.avatarContainer}>
          <Avatar.Image
            size={100}
            source={user?.photoUrl ? { uri: user.photoUrl } : { uri: 'https://via.placeholder.com/100' }}
          />
        </View>

        <View style={styles.form}>
          {editMode ? (
            <>
              <TextInput
                label="Display Name"
                value={displayName}
                onChangeText={setDisplayName}
                mode="outlined"
                disabled={updateLoading}
                error={!!error}
              />
              {error && <HelperText type="error">{error}</HelperText>}
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={handleProfileUpdate}
                  loading={updateLoading}
                  disabled={updateLoading}
                  style={styles.button}
                >
                  Save
                </Button>
                <Button
                  mode="outlined"
                  onPress={() => {
                    setEditMode(false);
                    setDisplayName(user?.name || '');
                    setError(null);
                  }}
                  disabled={updateLoading}
                  style={styles.button}
                >
                  Cancel
                </Button>
              </View>
            </>
          ) : (
            <>
              <TextInput
                label="Display Name"
                value={user?.name || ''}
                disabled
                mode="outlined"
              />
              <TextInput
                label="Email"
                value={user?.email || ''}
                disabled
                mode="outlined"
              />
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={() => setEditMode(true)}
                  style={styles.button}
                >
                  Edit Profile
                </Button>
                <Button
                  mode="outlined"
                  onPress={handleLogout}
                  loading={isLoading}
                  disabled={isLoading}
                  style={styles.button}
                >
                  Logout
                </Button>
              </View>
            </>
          )}
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  avatarContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  form: {
    gap: 16,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  button: {
    flex: 1,
    marginHorizontal: 4,
  },
});

================
File: features/profile/types/profile.ts
================
import { BaseEntity, Gender, BloodType, MeasurementSystem, PrivacyLevel } from '../../../core/types/base';

export interface Biometrics {
  height?: number;  // in centimeters
  weight?: number;  // in kilograms
  bloodType?: BloodType;
}

export interface Preferences {
  measurementSystem: MeasurementSystem;
  notifications: boolean;
  privacyLevel: PrivacyLevel;
  dailyGoals?: {
    steps?: number;
    sleep?: number;  // in minutes
    water?: number;  // in milliliters
  };
}

export interface Profile extends BaseEntity {
  firstName: string;
  lastName: string;
  dateOfBirth: Date;
  gender: Gender;
  biometrics: Biometrics;
  preferences: Preferences;
}

================
File: navigation/AppStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AppStackParamList } from './types';
import { TabNavigator } from './TabNavigator';
import { useTheme } from 'react-native-paper';

const Stack = createNativeStackNavigator<AppStackParamList>();

export const AppStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Stack.Screen 
        name="MainTabs" 
        component={TabNavigator}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AuthStackParamList } from './types';
import { useTheme } from 'react-native-paper';
import { LoginScreen } from '../features/auth/components/LoginScreen';
import { RegisterScreen } from '../features/auth/components/RegisterScreen';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export const AuthStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
        headerShown: false, // Hide header for all auth screens
      }}
    >
      <Stack.Screen 
        name="Login" 
        component={LoginScreen}
      />
      <Stack.Screen 
        name="Register" 
        component={RegisterScreen}
      />
    </Stack.Navigator>
  );
};

================
File: navigation/RootNavigator.tsx
================
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useApp } from '../context/AppContext';
import { useAuth } from '../context/AuthContext';
import { AppStack } from './AppStack';
import { AuthStack } from './AuthStack';
import { ActivityIndicator, View } from 'react-native';

// Inline LoadingScreen component until we create a separate one
const LoadingScreen = () => {
  const { theme } = useApp();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff' }}>
      <ActivityIndicator size="large" color={theme.colors.primary} />
    </View>
  );
};

const Stack = createNativeStackNavigator();

export const RootNavigator = () => {
  const { theme } = useApp();
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <NavigationContainer theme={theme}>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {user ? (
          <Stack.Screen name="App" component={AppStack} />
        ) : (
          <Stack.Screen name="Auth" component={AuthStack} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

================
File: navigation/TabNavigator.tsx
================
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme } from 'react-native-paper';
import { HomeScreen } from '../features/home/components/HomeScreen';
import { LeaderboardScreen } from '../features/leaderboard/components/LeaderboardScreen';
import { ProfileScreen } from '../features/profile/components/ProfileScreen';

const Tab = createBottomTabNavigator();

export const TabNavigator = () => {
  const theme = useTheme();

  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.outline,
        },
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          title: 'Health Dashboard',
        }}
      />
      <Tab.Screen
        name="Leaderboard"
        component={LeaderboardScreen}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
      />
    </Tab.Navigator>
  );
};

================
File: navigation/types.ts
================
export type RootStackParamList = {
  Auth: undefined;
  App: undefined;
};

export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
};

export type AppStackParamList = {
  MainTabs: undefined;
};

export type TabParamList = {
  Home: undefined;
  Leaderboard: undefined;
  Profile: undefined;
};

================
File: services/authService.ts
================
import AsyncStorage from '@react-native-async-storage/async-storage';
import { StorageService } from './storageService';

export interface User {
  id: string;
  email: string;
  displayName: string;
  photoUrl?: string;
}

type AuthStateListener = (user: User | null) => void;

class AuthService {
  private static instance: AuthService;
  private currentUser: User | null = null;
  private listeners: Set<AuthStateListener> = new Set();

  private constructor() {
    // Initialize by loading user from storage
    this.loadInitialUser();
  }

  private async loadInitialUser() {
    try {
      const userData = await AsyncStorage.getItem('user');
      if (userData) {
        const user = JSON.parse(userData);
        this.currentUser = user;
        this.notifyListeners();
      }
    } catch (error) {
      console.error('Error loading initial user:', error);
    }
  }

  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }

  public async getCurrentUser(): Promise<User | null> {
    if (this.currentUser) return this.currentUser;
    
    const userData = await StorageService.getUserData();
    if (userData) {
      this.currentUser = userData;
      return userData;
    }
    return null;
  }

  public async setCurrentUser(user: User | null): Promise<void> {
    this.currentUser = user;
    if (user) {
      await Promise.all([
        AsyncStorage.setItem('user', JSON.stringify(user)),
        StorageService.setUserData(user)
      ]);
    } else {
      await Promise.all([
        AsyncStorage.removeItem('user'),
        StorageService.clearAll()
      ]);
    }
    this.notifyListeners();
  }

  public addAuthStateListener(listener: AuthStateListener): () => void {
    this.listeners.add(listener);
    // Return cleanup function
    return () => {
      this.listeners.delete(listener);
    };
  }

  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.currentUser));
  }
}

export default AuthService.getInstance();

================
File: services/storageService.ts
================
import AsyncStorage from '@react-native-async-storage/async-storage';

const STORAGE_KEYS = {
  AUTH_TOKEN: 'auth_token',
  USER_DATA: 'user_data',
} as const;

export class StorageService {
  static async setAuthToken(token: string): Promise<void> {
    await AsyncStorage.setItem(STORAGE_KEYS.AUTH_TOKEN, token);
  }

  static async getAuthToken(): Promise<string | null> {
    return AsyncStorage.getItem(STORAGE_KEYS.AUTH_TOKEN);
  }

  static async removeAuthToken(): Promise<void> {
    await AsyncStorage.removeItem(STORAGE_KEYS.AUTH_TOKEN);
  }

  static async setUserData(userData: any): Promise<void> {
    await AsyncStorage.setItem(STORAGE_KEYS.USER_DATA, JSON.stringify(userData));
  }

  static async getUserData(): Promise<any | null> {
    const data = await AsyncStorage.getItem(STORAGE_KEYS.USER_DATA);
    return data ? JSON.parse(data) : null;
  }

  static async removeUserData(): Promise<void> {
    await AsyncStorage.removeItem(STORAGE_KEYS.USER_DATA);
  }

  static async clearAll(): Promise<void> {
    await AsyncStorage.multiRemove([
      STORAGE_KEYS.AUTH_TOKEN,
      STORAGE_KEYS.USER_DATA,
    ]);
  }
}

================
File: theme/index.ts
================
import { MD3DarkTheme, MD3LightTheme } from 'react-native-paper';
import { MD3Colors } from 'react-native-paper/lib/typescript/types';

// Custom colors for metrics
const metricColors = {
  steps: '#20B2AA',      // Light sea green
  distance: '#20B2AA',   // Light sea green
  score: '#9B59B6',      // Purpureus
  calories: '#FF6B6B',   // Light red
  sleep: '#9B59B6',      // Purpureus
};

export const lightColors: MD3Colors = {
  ...MD3LightTheme.colors,
  primary: '#98DFD6',  // Seafoam green
  onPrimary: '#FFFFFF',
  primaryContainer: '#E0F7F6',
  onPrimaryContainer: '#003D3A',
  secondary: '#98DFD6',  // Changed to match primary
  onSecondary: '#FFFFFF',
  secondaryContainer: '#F3E5F5',
  onSecondaryContainer: '#4A2D59',
  background: '#FFFFFF',
  surface: '#FFFFFF',
  surfaceVariant: '#F5F5F5',
  onSurfaceVariant: '#666666',
  error: '#FF6B6B',
  onError: '#FFFFFF',
  errorContainer: '#FFE5E5',
  onErrorContainer: '#660000',
};

export const darkColors: MD3Colors = {
  ...MD3DarkTheme.colors,
  primary: '#20B2AA',
  onPrimary: '#FFFFFF',
  primaryContainer: '#004D40',
  onPrimaryContainer: '#E0F7F6',
  secondary: '#9B59B6',
  onSecondary: '#FFFFFF',
  secondaryContainer: '#4A2D59',
  onSecondaryContainer: '#F3E5F5',
  background: '#121212',
  surface: '#121212',
  surfaceVariant: '#2C2C2C',
  onSurfaceVariant: '#CCCCCC',
  error: '#FF6B6B',
  onError: '#FFFFFF',
  errorContainer: '#660000',
  onErrorContainer: '#FFE5E5',
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: lightColors,
  metrics: metricColors,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: darkColors,
  metrics: metricColors,
};

// Create a custom theme that combines MD3Theme and NavigationTheme
export const customLightTheme = {
  ...MD3LightTheme,
  colors: {
    ...lightColors,
    // Add required navigation theme colors
    card: lightColors.surface,
    text: lightColors.onSurface,
    border: lightColors.outline,
    notification: lightColors.error,
  },
};

export const customDarkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...darkColors,
    // Add required navigation theme colors
    card: darkColors.surface,
    text: darkColors.onSurface,
    border: darkColors.outline,
    notification: darkColors.error,
  },
};

export type AppTheme = typeof customLightTheme;
export type MetricColorKey = keyof typeof metricColors;

// Helper function to get metric color
export const getMetricColor = (metricType: MetricColorKey): string => {
  return metricColors[metricType] || metricColors.score;
};
