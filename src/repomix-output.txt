This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-19T15:20:05.091Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
core/
  constants/
    metrics.ts
  types/
    api.ts
    base.ts
  utils/
    formatting.ts
    scoring.ts
features/
  health/
    hooks/
      useHealthData.ts
    services/
      AndroidHealthService.ts
      AppleHealthService.ts
      HealthService.ts
      HealthServiceFactory.ts
      platform.ts
  home/
    components/
      HomeScreen.tsx
      MetricCard.tsx
      MetricModal.tsx
  profile/
    types/
      health.ts
      profile.ts

================================================================
Repository Files
================================================================

================
File: core/constants/metrics.ts
================
export const HEALTH_METRICS = {
  STEPS: {
    DAILY_GOAL: 10000,
    MIN_HEALTHY: 5000,
    CONTRIBUTION_WEIGHT: 0.3
  },
  HEART_RATE: {
    RESTING_RANGE: {
      MIN: 60,
      MAX: 100
    },
    ZONES: {
      REST: { MIN: 60, MAX: 100 },
      LIGHT: { MIN: 101, MAX: 120 },
      MODERATE: { MIN: 121, MAX: 140 },
      VIGOROUS: { MIN: 141, MAX: 160 },
      MAXIMUM: { MIN: 161, MAX: 220 }
    },
    CONTRIBUTION_WEIGHT: 0.3
  },
  BLOOD_PRESSURE: {
    NORMAL: {
      SYSTOLIC: { MIN: 90, MAX: 120 },
      DIASTOLIC: { MIN: 60, MAX: 80 }
    }
  },
  SLEEP: {
    DAILY_GOAL: 480, // minutes (8 hours)
    MIN_HEALTHY: 360, // minutes (6 hours)
    STAGES: {
      DEEP: { MIN_PERCENTAGE: 0.13, MAX_PERCENTAGE: 0.23 },
      LIGHT: { MIN_PERCENTAGE: 0.4, MAX_PERCENTAGE: 0.6 },
      REM: { MIN_PERCENTAGE: 0.2, MAX_PERCENTAGE: 0.3 }
    },
    CONTRIBUTION_WEIGHT: 0.4
  }
};

================
File: core/types/api.ts
================
export interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
  timestamp?: Date;
}

export interface PaginatedResponse<T> extends ApiResponse<T> {
  page: number;
  limit: number;
  total: number;
  hasMore: boolean;
}

================
File: core/types/base.ts
================
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export type Gender = 'male' | 'female' | 'other' | 'prefer-not-to-say';
export type BloodType = 'A+' | 'A-' | 'B+' | 'B-' | 'AB+' | 'AB-' | 'O+' | 'O-';
export type MeasurementSystem = 'metric' | 'imperial';
export type PrivacyLevel = 'private' | 'friends' | 'public';
export type DataSource = 'apple_health' | 'google_fit' | 'manual';
export type SleepQuality = 'poor' | 'fair' | 'good' | 'excellent';

================
File: core/utils/formatting.ts
================
import { MeasurementSystem } from '../types/base';

export const formatDistance = (meters: number, system: MeasurementSystem): string => {
  if (system === 'imperial') {
    const miles = meters * 0.000621371;
    return `${miles.toFixed(2)} mi`;
  }
  const kilometers = meters / 1000;
  return `${kilometers.toFixed(2)} km`;
};

export const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return `${hours}h ${remainingMinutes}m`;
};

export const formatHeartRate = (bpm: number): string => {
  return `${Math.round(bpm)} bpm`;
};

export const formatBloodPressure = (systolic: number, diastolic: number): string => {
  return `${systolic}/${diastolic} mmHg`;
};

export const formatScore = (score: number): string => {
  return `${Math.round(score)}/100`;
};

================
File: core/utils/scoring.ts
================
import { HealthMetrics, HealthScore } from '../../features/profile/types/health';
import { HEALTH_METRICS } from '../constants/metrics';

export class HealthScoring {
  static calculateScore(metrics: HealthMetrics): HealthScore {
    const stepsScore = this.calculateStepsScore(metrics.steps);
    const heartScore = metrics.heartRate 
      ? this.calculateHeartScore(metrics.heartRate)
      : 0;
    const sleepScore = metrics.sleep
      ? this.calculateSleepScore(metrics.sleep)
      : 0;

    const overall = this.calculateOverallScore({
      steps: stepsScore,
      heart: heartScore,
      sleep: sleepScore
    });

    return {
      id: `score_${metrics.id}`,
      metricsId: metrics.id,
      overall,
      categories: {
        activity: stepsScore,
        cardio: heartScore,
        sleep: sleepScore
      },
      breakdown: {
        stepsContribution: stepsScore * HEALTH_METRICS.STEPS.CONTRIBUTION_WEIGHT,
        heartRateContribution: heartScore * HEALTH_METRICS.HEART_RATE.CONTRIBUTION_WEIGHT,
        sleepContribution: sleepScore * HEALTH_METRICS.SLEEP.CONTRIBUTION_WEIGHT
      }
    };
  }

  private static calculateStepsScore(steps: number): number {
    const { DAILY_GOAL, MIN_HEALTHY } = HEALTH_METRICS.STEPS;
    if (steps >= DAILY_GOAL) return 100;
    if (steps <= 0) return 0;
    return Math.min(100, (steps / DAILY_GOAL) * 100);
  }

  private static calculateHeartScore(heartRate: HealthMetrics['heartRate']): number {
    if (!heartRate) return 0;
    
    const { RESTING_RANGE } = HEALTH_METRICS.HEART_RATE;
    const restingScore = heartRate.average >= RESTING_RANGE.MIN && 
                        heartRate.average <= RESTING_RANGE.MAX ? 100 : 70;
    
    // Additional heart rate variability and zone analysis could be added here
    return restingScore;
  }

  private static calculateSleepScore(sleep: HealthMetrics['sleep']): number {
    if (!sleep) return 0;
    
    const { DAILY_GOAL, MIN_HEALTHY, STAGES } = HEALTH_METRICS.SLEEP;
    const totalSleep = sleep.deepSleep + sleep.lightSleep + sleep.remSleep;
    
    if (totalSleep >= DAILY_GOAL) return 100;
    if (totalSleep <= 0) return 0;
    
    const durationScore = (totalSleep / DAILY_GOAL) * 100;
    const qualityScore = this.calculateSleepQualityScore(sleep);
    
    return Math.min(100, (durationScore + qualityScore) / 2);
  }

  private static calculateSleepQualityScore(sleep: NonNullable<HealthMetrics['sleep']>): number {
    const totalSleep = sleep.deepSleep + sleep.lightSleep + sleep.remSleep;
    if (totalSleep === 0) return 0;

    const deepPercentage = sleep.deepSleep / totalSleep;
    const lightPercentage = sleep.lightSleep / totalSleep;
    const remPercentage = sleep.remSleep / totalSleep;

    const { STAGES } = HEALTH_METRICS.SLEEP;
    
    const deepScore = this.calculateStageScore(deepPercentage, STAGES.DEEP);
    const lightScore = this.calculateStageScore(lightPercentage, STAGES.LIGHT);
    const remScore = this.calculateStageScore(remPercentage, STAGES.REM);

    return (deepScore + lightScore + remScore) / 3;
  }

  private static calculateStageScore(
    percentage: number, 
    range: { MIN_PERCENTAGE: number; MAX_PERCENTAGE: number }
  ): number {
    if (percentage >= range.MIN_PERCENTAGE && percentage <= range.MAX_PERCENTAGE) {
      return 100;
    }
    const midPoint = (range.MIN_PERCENTAGE + range.MAX_PERCENTAGE) / 2;
    const distance = Math.abs(percentage - midPoint);
    const maxDistance = range.MAX_PERCENTAGE - midPoint;
    return Math.max(0, 100 * (1 - distance / maxDistance));
  }

  private static calculateOverallScore(scores: {
    steps: number;
    heart: number;
    sleep: number;
  }): number {
    const { STEPS, HEART_RATE, SLEEP } = HEALTH_METRICS;
    
    return Math.round(
      scores.steps * STEPS.CONTRIBUTION_WEIGHT +
      scores.heart * HEART_RATE.CONTRIBUTION_WEIGHT +
      scores.sleep * SLEEP.CONTRIBUTION_WEIGHT
    );
  }
}

================
File: features/health/hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { InteractionManager } from 'react-native';
import { HealthMetrics } from '../../profile/types/health';
import { HealthServiceFactory } from '../services/HealthServiceFactory';

const useHealthData = (profileId: string) => {
  const [metrics, setMetrics] = useState<HealthMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const healthService = HealthServiceFactory.getService();

  const initialize = useCallback(async () => {
    try {
      const initialized = await healthService.initialize();
      if (!initialized) {
        setError('Failed to initialize health service');
        setLoading(false);
        return;
      }

      const permissions = await healthService.checkPermissions();
      if (!permissions) {
        const granted = await healthService.requestPermissions();
        setHasPermission(granted);
      } else {
        setHasPermission(true);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to initialize health service');
    } finally {
      setLoading(false);
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions || !healthService.isInitialized()) return;

    setLoading(true);
    setError(null);

    try {
      const date = new Date().toISOString();
      const newMetrics = await healthService.fetchHealthData(date);
      setMetrics(newMetrics);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions]);

  useEffect(() => {
    InteractionManager.runAfterInteractions(() => {
      initialize();
    });
  }, [initialize]);

  useEffect(() => {
    if (hasPermissions) {
      fetchHealthData();
    }
  }, [hasPermissions, fetchHealthData]);

  const refresh = useCallback(() => {
    return fetchHealthData();
  }, [fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    hasPermissions,
    refresh,
  };
};

export default useHealthData;

================
File: features/health/services/AndroidHealthService.ts
================
import { Platform } from 'react-native';
import HealthConnect from '@stridekick/react-native-health-connect';
import { HealthMetrics } from '../../profile/types/health';
import { HealthService } from './HealthService';
import { SleepQuality, DataSource } from '../../../core/types/base';

interface HealthActivity {
  type?: string;
  value?: number;
  startTime?: string;
  endTime?: string;
  timestamp?: string;
  systolic?: number;
  diastolic?: number;
}

export class AndroidHealthService implements HealthService {
  private initialized: boolean = false;

  constructor() {
    if (Platform.OS !== 'android') {
      throw new Error('AndroidHealthService can only be used on Android devices');
    }
  }

  async initialize(): Promise<boolean> {
    if (this.initialized) return true;

    try {
      // Check if Health Connect is enabled
      const isEnabled = await HealthConnect.isEnabled();
      if (!isEnabled) {
        console.error('Health Connect is not enabled on this device');
        return false;
      }

      // Request permissions
      const granted = await this.requestPermissions();
      if (!granted) {
        console.error('Health Connect permissions not granted');
        return false;
      }

      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize Health Connect:', error);
      return false;
    }
  }

  isInitialized(): boolean {
    return this.initialized;
  }

  async checkPermissions(): Promise<boolean> {
    try {
      return await HealthConnect.authorize();
    } catch (error) {
      console.error('Failed to check permissions:', error);
      return false;
    }
  }

  async requestPermissions(): Promise<boolean> {
    try {
      return await HealthConnect.authorize();
    } catch (error) {
      console.error('Failed to request permissions:', error);
      return false;
    }
  }

  async fetchHealthData(date: string): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health Connect is not initialized');
    }

    try {
      // Get activities for the last day
      const activities = await HealthConnect.getActivities(1) as HealthActivity[];
      
      // Find activities for the requested date
      const dateActivities = activities.filter(activity => {
        const activityDate = new Date(activity.startTime || activity.timestamp || '');
        const requestDate = new Date(date);
        return activityDate.toDateString() === requestDate.toDateString();
      });

      // Calculate metrics from activities
      let steps = 0;
      let distance = 0;
      let heartRateReadings: number[] = [];
      let bloodPressureReadings: { systolic: number; diastolic: number; timestamp: Date }[] = [];
      let sleepSessions: { startTime: Date; endTime: Date }[] = [];

      dateActivities.forEach(activity => {
        if (activity.type === 'steps') {
          steps += activity.value || 0;
        }
        if (activity.type === 'distance') {
          distance += activity.value || 0;
        }
        if (activity.type === 'heart_rate' && activity.value) {
          heartRateReadings.push(activity.value);
        }
        if (activity.type === 'blood_pressure' && activity.systolic && activity.diastolic && activity.timestamp) {
          bloodPressureReadings.push({
            systolic: activity.systolic,
            diastolic: activity.diastolic,
            timestamp: new Date(activity.timestamp)
          });
        }
        if (activity.type === 'sleep' && activity.startTime && activity.endTime) {
          sleepSessions.push({
            startTime: new Date(activity.startTime),
            endTime: new Date(activity.endTime)
          });
        }
      });

      // Calculate heart rate stats
      const avgHeartRate = heartRateReadings.length 
        ? heartRateReadings.reduce((a, b) => a + b, 0) / heartRateReadings.length 
        : 0;
      const maxHeartRate = heartRateReadings.length 
        ? Math.max(...heartRateReadings) 
        : 0;
      const minHeartRate = heartRateReadings.length 
        ? Math.min(...heartRateReadings) 
        : 0;

      // Calculate sleep metrics
      const totalSleepMs = sleepSessions.reduce((total, session) => {
        return total + (session.endTime.getTime() - session.startTime.getTime());
      }, 0);

      const sleepQuality = this.getSleepQuality(totalSleepMs);
      const firstSleep = sleepSessions[0] || { 
        startTime: new Date(), 
        endTime: new Date() 
      };

      const metricsId = `metrics_${Date.now()}`;

      return {
        id: metricsId,
        profileId: '', // This should be set by the caller
        date: new Date(date),
        steps,
        flights: 0, // Health Connect doesn't track flights climbed
        distance,
        heartRate: {
          average: Math.round(avgHeartRate),
          max: Math.round(maxHeartRate),
          min: Math.round(minHeartRate),
          readings: heartRateReadings.map((value, index) => ({
            id: `hr_${Date.now()}_${index}`,
            metricsId,
            value,
            timestamp: new Date()
          }))
        },
        bloodPressure: bloodPressureReadings.map((reading, index) => ({
          id: `bp_${Date.now()}_${index}`,
          metricsId,
          ...reading
        })),
        sleep: {
          id: `sleep_${Date.now()}`,
          metricsId,
          deepSleep: Math.round(totalSleepMs * 0.2 / 60000), // Convert ms to minutes, estimate 20% deep sleep
          lightSleep: Math.round(totalSleepMs * 0.5 / 60000), // Convert ms to minutes, estimate 50% light sleep
          remSleep: Math.round(totalSleepMs * 0.3 / 60000), // Convert ms to minutes, estimate 30% REM sleep
          awakeTime: 0, // Not provided by Health Connect
          startTime: firstSleep.startTime,
          endTime: firstSleep.endTime,
          quality: sleepQuality
        },
        source: 'google_fit' as DataSource,
        createdAt: new Date(),
        updatedAt: new Date()
      };
    } catch (error) {
      console.error('Failed to fetch health data:', error);
      throw error;
    }
  }

  private getSleepQuality(sleepDuration: number): SleepQuality {
    if (sleepDuration > 8 * 60 * 60 * 1000) return 'excellent';
    if (sleepDuration > 7 * 60 * 60 * 1000) return 'good';
    if (sleepDuration > 5 * 60 * 60 * 1000) return 'fair';
    return 'poor';
  }
}

================
File: features/health/services/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
  HealthValue,
} from 'react-native-health';
import { HealthMetrics } from '../../profile/types/health';
import { HealthService } from './HealthService';

const { Permissions } = AppleHealthKit.Constants;

export class AppleHealthService implements HealthService {
  private initialized: boolean = false;

  private readonly permissions: HealthKitPermissions = {
    permissions: {
      read: [
        Permissions.Steps,
        Permissions.FlightsClimbed,
        Permissions.DistanceWalkingRunning,
        Permissions.HeartRate,
        Permissions.BloodPressureDiastolic,
        Permissions.BloodPressureSystolic,
        Permissions.SleepAnalysis,
      ],
      write: [],
    },
  };

  async initialize(): Promise<boolean> {
    if (this.initialized) return true;

    try {
      await AppleHealthKit.initHealthKit(this.permissions);
      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Failed to initialize HealthKit:', error);
      return false;
    }
  }

  isInitialized(): boolean {
    return this.initialized;
  }

  async checkPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      AppleHealthKit.isAvailable((error: string, result: boolean) => {
        if (error) {
          console.error('HealthKit is not available:', error);
          resolve(false);
          return;
        }
        resolve(result);
      });
    });
  }

  async requestPermissions(): Promise<boolean> {
    try {
      await AppleHealthKit.initHealthKit(this.permissions);
      return true;
    } catch (error) {
      console.error('Failed to request HealthKit permissions:', error);
      return false;
    }
  }

  async fetchHealthData(date: string): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('HealthKit is not initialized');
    }

    const options: HealthInputOptions = {
      date,
    };

    const [steps, flights, distance, heartRate, bloodPressure, sleep] = await Promise.all([
      this.getSteps(options),
      this.getFlightsClimbed(options),
      this.getDistance(options),
      this.getHeartRate(options),
      this.getBloodPressure(options),
      this.getSleep(options),
    ]);

    return {
      steps,
      flights,
      distance,
      heartRate,
      bloodPressure,
      sleep,
    };
  }

  private getSteps(options: HealthInputOptions): Promise<number> {
    return new Promise((resolve) => {
      AppleHealthKit.getStepCount(options, (err: string, results: HealthValue) => {
        if (err) {
          console.error('Error getting steps:', err);
          resolve(0);
          return;
        }
        resolve(results.value);
      });
    });
  }

  private getFlightsClimbed(options: HealthInputOptions): Promise<number> {
    return new Promise((resolve) => {
      AppleHealthKit.getFlightsClimbed(options, (err: string, results: HealthValue) => {
        if (err) {
          console.error('Error getting flights climbed:', err);
          resolve(0);
          return;
        }
        resolve(results.value);
      });
    });
  }

  private getDistance(options: HealthInputOptions): Promise<number> {
    return new Promise((resolve) => {
      AppleHealthKit.getDistanceWalkingRunning(options, (err: string, results: HealthValue) => {
        if (err) {
          console.error('Error getting distance:', err);
          resolve(0);
          return;
        }
        resolve(results.value);
      });
    });
  }

  private getHeartRate(options: HealthInputOptions): Promise<number> {
    return new Promise((resolve) => {
      AppleHealthKit.getHeartRateSamples(options, (err: string, results: HealthValue[]) => {
        if (err || !results.length) {
          console.error('Error getting heart rate:', err);
          resolve(0);
          return;
        }
        resolve(results[results.length - 1].value);
      });
    });
  }

  private getBloodPressure(options: HealthInputOptions): Promise<{ systolic: number; diastolic: number }> {
    return new Promise((resolve) => {
      AppleHealthKit.getBloodPressureSamples(options, (err: string, results: any[]) => {
        if (err || !results.length) {
          console.error('Error getting blood pressure:', err);
          resolve({ systolic: 0, diastolic: 0 });
          return;
        }
        const latest = results[results.length - 1];
        resolve({
          systolic: latest.bloodPressureSystolicValue,
          diastolic: latest.bloodPressureDiastolicValue,
        });
      });
    });
  }

  private getSleep(options: HealthInputOptions): Promise<number> {
    return new Promise((resolve) => {
      AppleHealthKit.getSleepSamples(options, (err: string, results: any[]) => {
        if (err || !results.length) {
          console.error('Error getting sleep:', err);
          resolve(0);
          return;
        }
        const totalSleep = results.reduce((acc, curr) => {
          const start = new Date(curr.startDate).getTime();
          const end = new Date(curr.endDate).getTime();
          return acc + (end - start);
        }, 0);
        resolve(Math.round(totalSleep / (1000 * 60 * 60))); // Convert to hours
      });
    });
  }
}

================
File: features/health/services/HealthService.ts
================
import { HealthMetrics } from '../../profile/types/health';

export interface HealthService {
  initialize(): Promise<boolean>;
  checkPermissions(): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  fetchHealthData(date: string): Promise<HealthMetrics>;
  isInitialized(): boolean;
}

================
File: features/health/services/HealthServiceFactory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './HealthService';
import { AndroidHealthService } from './AndroidHealthService';
import { AppleHealthService } from './AppleHealthService';

export class HealthServiceFactory {
  private static instance: HealthService;

  static getService(): HealthService {
    if (!HealthServiceFactory.instance) {
      HealthServiceFactory.instance = Platform.OS === 'ios'
        ? new AppleHealthService()
        : new AndroidHealthService();
    }
    return HealthServiceFactory.instance;
  }
}

================
File: features/health/services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

export const getCurrentPlatform = (): HealthPlatform => {
  if (Platform.OS === 'ios') {
    return {
      id: 'apple_health',
      name: 'Apple Health',
      version: '1.0.0',
      type: 'apple_health'
    };
  }
  
  if (Platform.OS === 'android') {
    return {
      id: 'health_connect',
      name: 'Health Connect',
      version: '1.0.0',
      type: 'health_connect'
    };
  }
  
  return {
    id: 'manual',
    name: 'Manual Entry',
    version: '1.0.0',
    type: 'manual'
  };
};

================
File: features/home/components/HomeScreen.tsx
================
import React, { useState } from 'react';
import { StyleSheet, Text, View, ScrollView, RefreshControl, ActivityIndicator } from 'react-native';
import { StatusBar } from 'expo-status-bar';
import useHealthData from '../../health/hooks/useHealthData';
import { formatDistance } from '../../../core/utils/formatting';
import { MetricCard } from './MetricCard';
import { MetricModal } from './MetricModal';
import { HealthMetrics } from '../../profile/types/health';

// TODO: Replace with actual user profile management
const MOCK_PROFILE_ID = 'test_user_1';

type MetricType = 'steps' | 'distance' | 'flights' | 'score';

interface ModalData {
  type: MetricType;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

export const HomeScreen: React.FC = () => {
  const { metrics, loading, error, refreshMetrics } = useHealthData(MOCK_PROFILE_ID);
  const [refreshing, setRefreshing] = React.useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedMetric, setSelectedMetric] = useState<ModalData | null>(null);

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    await refreshMetrics();
    setRefreshing(false);
  }, [refreshMetrics]);

  const handleMetricPress = (type: MetricType, metrics: HealthMetrics) => {
    let modalData: ModalData;

    switch (type) {
      case 'steps':
        modalData = {
          type,
          title: 'Daily Steps',
          value: metrics.steps,
          additionalInfo: [
            { label: 'Goal', value: '10,000 steps' },
            { label: 'Distance', value: formatDistance(metrics.distance, 'metric') },
          ],
        };
        break;

      case 'distance':
        modalData = {
          type,
          title: 'Distance Walked',
          value: formatDistance(metrics.distance, 'metric'),
          additionalInfo: [
            { label: 'Steps', value: metrics.steps },
            { label: 'Flights Climbed', value: metrics.flights },
          ],
        };
        break;

      case 'flights':
        modalData = {
          type,
          title: 'Flights Climbed',
          value: metrics.flights,
          additionalInfo: [
            { label: 'Elevation', value: `${metrics.flights * 3}m` },
            { label: 'Steps', value: metrics.steps },
          ],
        };
        break;

      case 'score':
        modalData = {
          type,
          title: 'Health Score',
          value: `${metrics.score?.overall}/100`,
          additionalInfo: [
            { label: 'Activity Score', value: `${metrics.score?.categories.activity}/100` },
            { label: 'Cardio Score', value: `${metrics.score?.categories.cardio}/100` },
            { label: 'Sleep Score', value: `${metrics.score?.categories.sleep}/100` },
          ],
        };
        break;

      default:
        return;
    }

    setSelectedMetric(modalData);
    setModalVisible(true);
  };

  if (loading && !refreshing) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#0000ff" />
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.container}>
        <Text style={styles.error}>{error}</Text>
      </View>
    );
  }

  return (
    <>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        <View style={styles.container}>
          <View style={styles.dataContainer}>
            <Text style={styles.title}>Daily Health Metrics</Text>

            <MetricCard
              label="Steps"
              value={metrics?.steps || 0}
              onPress={() => metrics && handleMetricPress('steps', metrics)}
            />

            <MetricCard
              label="Distance"
              value={metrics ? formatDistance(metrics.distance, 'metric') : '0 km'}
              onPress={() => metrics && handleMetricPress('distance', metrics)}
            />

            <MetricCard
              label="Flights Climbed"
              value={metrics?.flights || 0}
              onPress={() => metrics && handleMetricPress('flights', metrics)}
            />

            {metrics?.score && (
              <MetricCard
                label="Health Score"
                value={`${metrics.score.overall}/100`}
                onPress={() => handleMetricPress('score', metrics)}
                style={styles.scoreCard}
              />
            )}
          </View>
          <StatusBar style="auto" />
        </View>
      </ScrollView>

      {selectedMetric && (
        <MetricModal
          visible={modalVisible}
          onClose={() => setModalVisible(false)}
          title={selectedMetric.title}
          value={selectedMetric.value}
          data={selectedMetric.data}
          additionalInfo={selectedMetric.additionalInfo}
        />
      )}
    </>
  );
};

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
  },
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 20,
  },
  dataContainer: {
    width: '90%',
    alignItems: 'stretch',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 20,
    textAlign: 'center',
  },
  error: {
    color: '#ff0000',
    fontSize: 16,
    textAlign: 'center',
    margin: 20,
  },
  scoreCard: {
    marginTop: 20,
    backgroundColor: '#f8f9ff',
    borderWidth: 1,
    borderColor: '#e0e0ff',
  },
});

================
File: features/home/components/MetricCard.tsx
================
import React from 'react';
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native';

interface MetricCardProps {
  label: string;
  value: string | number;
  onPress?: () => void;
  style?: object;
}

export const MetricCard: React.FC<MetricCardProps> = ({
  label,
  value,
  onPress,
  style,
}) => {
  return (
    <TouchableOpacity onPress={onPress} disabled={!onPress}>
      <View style={[styles.metricCard, style]}>
        <Text style={styles.label}>{label}</Text>
        <Text style={styles.value}>{value}</Text>
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  metricCard: {
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 15,
    marginVertical: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 3.84,
    elevation: 5,
  },
  label: {
    fontSize: 16,
    color: '#666',
    marginBottom: 5,
  },
  value: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#000',
  },
});

================
File: features/home/components/MetricModal.tsx
================
import React from 'react';
import { StyleSheet, Text, View, Modal, TouchableOpacity, Dimensions } from 'react-native';
import { LineChart } from 'react-native-chart-kit';

interface MetricModalProps {
  visible: boolean;
  onClose: () => void;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

export const MetricModal: React.FC<MetricModalProps> = ({
  visible,
  onClose,
  title,
  value,
  data,
  additionalInfo,
}) => {
  return (
    <Modal
      animationType="slide"
      transparent={true}
      visible={visible}
      onRequestClose={onClose}
    >
      <View style={styles.centeredView}>
        <View style={styles.modalView}>
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Text style={styles.closeButtonText}>×</Text>
          </TouchableOpacity>

          <Text style={styles.modalTitle}>{title}</Text>
          <Text style={styles.modalValue}>{value}</Text>

          {data && data.values.length > 0 && (
            <View style={styles.chartContainer}>
              <LineChart
                data={{
                  labels: data.labels,
                  datasets: [{ data: data.values }],
                }}
                width={Dimensions.get('window').width - 80}
                height={220}
                chartConfig={{
                  backgroundColor: '#ffffff',
                  backgroundGradientFrom: '#ffffff',
                  backgroundGradientTo: '#ffffff',
                  decimalPlaces: 0,
                  color: (opacity = 1) => `rgba(74, 144, 226, ${opacity})`,
                  style: {
                    borderRadius: 16,
                  },
                }}
                style={styles.chart}
                bezier
              />
            </View>
          )}

          {additionalInfo && additionalInfo.length > 0 && (
            <View style={styles.additionalInfo}>
              {additionalInfo.map((info, index) => (
                <View key={index} style={styles.infoRow}>
                  <Text style={styles.infoLabel}>{info.label}</Text>
                  <Text style={styles.infoValue}>{info.value}</Text>
                </View>
              ))}
            </View>
          )}
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  centeredView: {
    flex: 1,
    justifyContent: 'flex-end',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalView: {
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    paddingTop: 30,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -4,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
    maxHeight: '80%',
  },
  closeButton: {
    position: 'absolute',
    right: 20,
    top: 20,
    zIndex: 1,
  },
  closeButtonText: {
    fontSize: 28,
    color: '#666',
  },
  modalTitle: {
    fontSize: 20,
    color: '#666',
    marginBottom: 5,
  },
  modalValue: {
    fontSize: 36,
    fontWeight: 'bold',
    color: '#000',
    marginBottom: 20,
  },
  chartContainer: {
    marginVertical: 20,
    alignItems: 'center',
  },
  chart: {
    borderRadius: 16,
  },
  additionalInfo: {
    marginTop: 20,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    paddingTop: 20,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  infoLabel: {
    fontSize: 16,
    color: '#666',
  },
  infoValue: {
    fontSize: 16,
    fontWeight: '500',
    color: '#000',
  },
});

================
File: features/profile/types/health.ts
================
import { BaseEntity, DataSource, SleepQuality } from '../../../core/types/base';

export interface HeartRateReading {
  id: string;
  metricsId: string;
  value: number;
  timestamp: Date;
}

export interface BloodPressureReading {
  id: string;
  metricsId: string;
  systolic: number;
  diastolic: number;
  timestamp: Date;
}

export interface SleepMetrics {
  id: string;
  metricsId: string;
  startTime: Date;
  endTime: Date;
  quality: SleepQuality;
  deepSleep: number;    // in minutes
  lightSleep: number;   // in minutes
  remSleep: number;     // in minutes
  awakeTime: number;    // in minutes
}

export interface HealthScore {
  id: string;
  metricsId: string;
  overall: number;  // 0-100
  categories: {
    activity: number;     // 0-100
    cardio: number;       // 0-100
    sleep: number;        // 0-100
  };
  breakdown: {
    stepsContribution: number;
    heartRateContribution: number;
    sleepContribution: number;
  };
}

export interface HealthMetrics extends BaseEntity {
  profileId: string;
  date: Date;
  steps: number;
  distance: number;  // in meters
  flights: number;
  heartRate?: {
    average: number;
    max: number;
    min: number;
    readings: HeartRateReading[];
  };
  bloodPressure?: BloodPressureReading[];
  sleep?: SleepMetrics;
  score?: HealthScore;
  source: DataSource;
}

================
File: features/profile/types/profile.ts
================
import { BaseEntity, Gender, BloodType, MeasurementSystem, PrivacyLevel } from '../../../core/types/base';

export interface Biometrics {
  height?: number;  // in centimeters
  weight?: number;  // in kilograms
  bloodType?: BloodType;
}

export interface Preferences {
  measurementSystem: MeasurementSystem;
  notifications: boolean;
  privacyLevel: PrivacyLevel;
  dailyGoals?: {
    steps?: number;
    sleep?: number;  // in minutes
    water?: number;  // in milliliters
  };
}

export interface Profile extends BaseEntity {
  firstName: string;
  lastName: string;
  dateOfBirth: Date;
  gender: Gender;
  biometrics: Biometrics;
  preferences: Preferences;
}
