This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T20:36:29.229Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
context/
  AppContext.tsx
  AuthContext.tsx
core/
  constants/
    metrics.ts
  types/
    api.ts
    base.ts
  utils/
    formatting.ts
    scoring.ts
features/
  health/
    hooks/
      useHealthData.ts
    services/
      platforms/
        AppleHealthService.ts
        GoogleHealthService.ts
        MockHealthService.ts
      base.ts
      factory.ts
      platform.ts
      types.ts
    types/
      health.ts
  home/
    components/
      HomeScreen.tsx
      MetricCard.tsx
      MetricModal.tsx
  leaderboard/
    components/
      LeaderboardScreen.tsx
  profile/
    components/
      ProfileScreen.tsx
    types/
      profile.ts
navigation/
  AppStack.tsx
  AuthStack.tsx
  RootNavigator.tsx
  TabNavigator.tsx
  types.ts
theme/
  index.ts

================================================================
Repository Files
================================================================

================
File: context/AppContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useColorScheme } from 'react-native';
import { customLightTheme, customDarkTheme, AppTheme } from '../theme';

interface AppContextType {
  theme: AppTheme;
  isDarkMode: boolean;
  isLoading: boolean;
};

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const colorScheme = useColorScheme();
  const [isDarkMode, setIsDarkMode] = useState(colorScheme === 'dark');
  const [theme, setTheme] = useState(isDarkMode ? customDarkTheme : customLightTheme);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeApp = async () => {
      try {
        const savedTheme = await AsyncStorage.getItem('theme');
        if (savedTheme) {
          setIsDarkMode(savedTheme === 'dark');
          setTheme(savedTheme === 'dark' ? customDarkTheme : customLightTheme);
        }
      } catch (error) {
        console.error('Error loading theme:', error);
      } finally {
        setIsLoading(false);
      }
    };

    initializeApp();
  }, []);

  useEffect(() => {
    setTheme(isDarkMode ? customDarkTheme : customLightTheme);
  }, [isDarkMode]);

  const toggleTheme = async () => {
    const newIsDarkMode = !isDarkMode;
    setIsDarkMode(newIsDarkMode);
    setTheme(newIsDarkMode ? customDarkTheme : customLightTheme);
    try {
      await AsyncStorage.setItem('theme', newIsDarkMode ? 'dark' : 'light');
    } catch (error) {
      console.error('Error saving theme:', error);
    }
  };

  return (
    <AppContext.Provider value={{ theme, isDarkMode, isLoading }}>
      {children}
    </AppContext.Provider>
  );
};

export const useApp = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
};

================
File: context/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

type AuthState = {
  isAuthenticated: boolean;
  userId: string | null;
  isLoading: boolean;
  error: string | null;
  user?: {
    displayName?: string;
    email?: string;
  };
};

type AuthContextType = AuthState & {
  login: (userId: string) => Promise<void>;
  logout: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<AuthState>({
    isAuthenticated: false,
    userId: null,
    isLoading: true,
    error: null,
  });

  useEffect(() => {
    const initializeAuth = async () => {
      try {
        const storedUserId = await AsyncStorage.getItem('userId');
        if (storedUserId) {
          setState(prev => ({
            ...prev,
            isAuthenticated: true,
            userId: storedUserId,
            isLoading: false,
          }));
        } else {
          setState(prev => ({ ...prev, isLoading: false }));
        }
      } catch (error) {
        setState(prev => ({
          ...prev,
          error: 'Failed to load auth state',
          isLoading: false,
        }));
      }
    };

    initializeAuth();
  }, []);

  const login = async (userId: string) => {
    try {
      await AsyncStorage.setItem('userId', userId);
      setState(prev => ({
        ...prev,
        isAuthenticated: true,
        userId,
        error: null,
        user: {
          displayName: 'Test User',
          email: 'test@example.com',
        },
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to login',
      }));
      throw new Error('Failed to login');
    }
  };

  const logout = async () => {
    try {
      await AsyncStorage.removeItem('userId');
      setState(prev => ({
        ...prev,
        isAuthenticated: false,
        userId: null,
        error: null,
      }));
    } catch (error) {
      setState(prev => ({
        ...prev,
        error: 'Failed to logout',
      }));
      throw new Error('Failed to logout');
    }
  };

  return (
    <AuthContext.Provider
      value={{
        ...state,
        login,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: core/constants/metrics.ts
================
export const HEALTH_METRICS = {
  STEPS: {
    DAILY_GOAL: 10000,
    MIN_HEALTHY: 5000
  },
  DISTANCE: {
    DAILY_GOAL: 8.05, // kilometers (approximately 5 miles)
    MIN_HEALTHY: 4.0  // kilometers
  }
};

================
File: core/types/api.ts
================
export interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
  timestamp?: Date;
}

export interface PaginatedResponse<T> extends ApiResponse<T> {
  page: number;
  limit: number;
  total: number;
  hasMore: boolean;
}

================
File: core/types/base.ts
================
export interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export type Gender = 'male' | 'female' | 'other' | 'prefer-not-to-say';
export type BloodType = 'A+' | 'A-' | 'B+' | 'B-' | 'AB+' | 'AB-' | 'O+' | 'O-';
export type MeasurementSystem = 'metric' | 'imperial';
export type PrivacyLevel = 'private' | 'friends' | 'public';
export type DataSource = 'apple_health' | 'google_fit' | 'manual';
export type SleepQuality = 'poor' | 'fair' | 'good' | 'excellent';

================
File: core/utils/formatting.ts
================
import { MeasurementSystem } from '../types/base';

export const formatDistance = (kilometers: number, system: MeasurementSystem): string => {
  if (system === 'imperial') {
    const miles = kilometers * 0.621371;
    return `${miles.toFixed(2)} mi`;
  }
  return `${kilometers.toFixed(2)} km`;
};

export const formatDuration = (minutes: number): string => {
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return `${hours}h ${remainingMinutes}m`;
};

export const formatHeartRate = (bpm: number): string => {
  return `${Math.round(bpm)} bpm`;
};

export const formatBloodPressure = (systolic: number, diastolic: number): string => {
  return `${systolic}/${diastolic} mmHg`;
};

export const formatScore = (score: number): string => {
  return `${Math.round(score)}/100`;
};

================
File: core/utils/scoring.ts
================
import { HealthMetrics, HealthScore } from '../../features/health/types/health';
import { HEALTH_METRICS } from '../constants/metrics';

export class HealthScoring {
  static calculateScore(metrics: HealthMetrics): HealthScore {
    const steps = metrics.steps || 0;
    const distance = metrics.distance || 0;
    
    const stepsScore = this.calculateStepsScore(steps);
    const distanceScore = this.calculateDistanceScore(distance);

    const overall = (stepsScore + distanceScore) / 2;

    return {
      overall: Math.round(overall),
      categories: {
        steps: Math.round(stepsScore),
        distance: Math.round(distanceScore)
      },
      dailyVictory: steps >= HEALTH_METRICS.STEPS.DAILY_GOAL
    };
  }

  private static calculateStepsScore(steps: number): number {
    const { DAILY_GOAL, MIN_HEALTHY } = HEALTH_METRICS.STEPS;
    if (steps >= DAILY_GOAL) return 100;
    if (steps <= 0) return 0;
    return Math.min(100, (steps / DAILY_GOAL) * 100);
  }

  private static calculateDistanceScore(distance: number): number {
    const { DAILY_GOAL, MIN_HEALTHY } = HEALTH_METRICS.DISTANCE;
    // Convert distance to km if using imperial system
    const distanceInKm = distance;
    if (distanceInKm >= DAILY_GOAL) return 100;
    if (distanceInKm <= 0) return 0;
    return Math.min(100, (distanceInKm / DAILY_GOAL) * 100);
  }
}

================
File: features/health/hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { HealthMetrics } from '../types/health';
import { HealthServiceFactory } from '../services/factory';
import AppleHealthKit from 'react-native-health';

const { Permissions } = AppleHealthKit.Constants;

const defaultPermissions = {
  permissions: {
    read: [
      Permissions.Steps,
      Permissions.DistanceWalkingRunning,
    ],
    write: [],
  },
};

const healthService = HealthServiceFactory.getService();

const useHealthData = (profileId: string) => {
  const [metrics, setMetrics] = useState<HealthMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const initialize = useCallback(async () => {
    try {
      const initialized = await healthService.initialize(defaultPermissions);
      if (initialized) {
        const permissions = await healthService.hasPermissions();
        setHasPermission(permissions);
        return permissions;
      }
      return false;
    } catch (err) {
      console.error('Health service initialization error:', err);
      setError('Failed to initialize health service');
      return false;
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions) {
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const newMetrics = await healthService.getMetrics();
      setMetrics({
        ...newMetrics,
        profileId,
      });
    } catch (err) {
      console.error('Error fetching health data:', err);
      setError('Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions, profileId]);

  const refresh = useCallback(async () => {
    await fetchHealthData();
  }, [fetchHealthData]);

  useEffect(() => {
    const setupHealthData = async () => {
      const initialized = await initialize();
      if (initialized) {
        await fetchHealthData();
      }
    };

    setupHealthData();
  }, [initialize, fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    refresh,
    hasPermissions,
  };
};

export default useHealthData;

================
File: features/health/services/platforms/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
} from 'react-native-health';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class AppleHealthService extends BaseHealthService {
  protected source = 'apple_health' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return new Promise((resolve) => {
      AppleHealthKit.initHealthKit(config as HealthKitPermissions, (error: string) => {
        resolve(!error);
      });
    });
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      AppleHealthKit.getStepCount(options, (err, results) => {
        if (err) reject(err);
        else resolve(results.value);
      });
    });
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      AppleHealthKit.getDistanceWalkingRunning(options, (err, results) => {
        if (err) reject(err);
        else resolve(results.value / 1000); // Convert to kilometers
      });
    });
  }
}

================
File: features/health/services/platforms/GoogleHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class GoogleHealthService extends BaseHealthService {
  protected source = 'google_fit' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    // TODO: Implement Google Fit initialization
    return false;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions request
    return false;
  }

  protected async doHasPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions check
    return false;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }
}

================
File: features/health/services/platforms/MockHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class MockHealthService extends BaseHealthService {
  protected source = 'manual' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return true;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    // Return a random number of steps between 5000 and 15000
    return Math.floor(Math.random() * (15000 - 5000 + 1)) + 5000;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    // Return a random distance between 3 and 10 kilometers
    return Number((Math.random() * (10 - 3) + 3).toFixed(2));
  }
}

================
File: features/health/services/base.ts
================
import { HealthService, HealthServiceConfig } from './types';
import { HealthMetrics } from '../types/health';
import { HealthScoring } from '../../../core/utils/scoring';
import { DataSource } from '../../../core/types/base';

export abstract class BaseHealthService implements HealthService {
  protected initialized = false;
  protected abstract source: DataSource;

  async initialize(config: HealthServiceConfig): Promise<boolean> {
    if (this.initialized) return true;
    const success = await this.doInitialize(config);
    this.initialized = success;
    return success;
  }

  protected abstract doInitialize(config: HealthServiceConfig): Promise<boolean>;

  async requestPermissions(): Promise<boolean> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    return this.doRequestPermissions();
  }

  protected abstract doRequestPermissions(): Promise<boolean>;

  async hasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    return this.doHasPermissions();
  }

  protected abstract doHasPermissions(): Promise<boolean>;

  async getMetrics(date: Date = new Date()): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }

    const [steps, distance] = await Promise.all([
      this.getDailySteps(date),
      this.getDailyDistance(date),
    ]);

    const now = new Date();
    const id = `metrics_${now.getTime()}`;

    const metrics: HealthMetrics = {
      id,
      profileId: '', // Set from the calling context
      date: date.toISOString(),
      steps,
      distance,
      score: 0,
      source: this.source,
      createdAt: now,
      updatedAt: now,
    };

    const score = HealthScoring.calculateScore(metrics);
    metrics.score = score.overall;

    return metrics;
  }

  abstract getDailySteps(date?: Date): Promise<number>;
  abstract getDailyDistance(date?: Date): Promise<number>;
}

================
File: features/health/services/factory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './types';
import { AppleHealthService } from './platforms/AppleHealthService';
import { GoogleHealthService } from './platforms/GoogleHealthService';
import { MockHealthService } from './platforms/MockHealthService';
import { getCurrentPlatform } from './platform';

export class HealthServiceFactory {
  static getService(): HealthService {
    const currentPlatform = getCurrentPlatform();
    if (currentPlatform.id === 'apple_health') {
      return new AppleHealthService();
    }
    if (currentPlatform.id === 'google_fit') {
      return new GoogleHealthService();
    }
    return new MockHealthService();
  }
}

================
File: features/health/services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

const appleHealthPlatform: HealthPlatform = {
  id: 'apple_health',
  name: 'Apple Health',
  version: '1.0.0',
  type: 'apple_health'
};

const googleFitPlatform: HealthPlatform = {
  id: 'google_fit',
  name: 'Google Fit',
  version: '1.0.0',
  type: 'google_fit'
};

const manualPlatform: HealthPlatform = {
  id: 'manual',
  name: 'Manual Entry',
  version: '1.0.0',
  type: 'manual'
};

export const getCurrentPlatform = (): HealthPlatform => {
  if (Platform.OS === 'ios') {
    return appleHealthPlatform;
  }
  
  if (Platform.OS === 'android') {
    return googleFitPlatform;
  }
  
  return manualPlatform;
};

================
File: features/health/services/types.ts
================
import { HealthMetrics } from '../types/health';

export interface HealthServiceConfig {
  permissions: {
    read: string[];
    write: string[];
  };
  options?: Record<string, any>;
}

export interface HealthService {
  initialize(config: HealthServiceConfig): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  hasPermissions(): Promise<boolean>;
  getMetrics(date?: Date): Promise<HealthMetrics>;
  getDailySteps(date?: Date): Promise<number>;
  getDailyDistance(date?: Date): Promise<number>;
}

================
File: features/health/types/health.ts
================
import { DataSource } from '../../../core/types/base';

export interface HealthScore {
  overall: number;
  categories: {
    steps: number;
    distance: number;
  };
  dailyVictory: boolean;
}

export interface HealthMetrics {
  id: string;
  profileId: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
  source: DataSource;
  createdAt: Date;
  updatedAt: Date;
}

export type MetricType = 'steps' | 'distance' | 'score';

export interface HealthState {
  isInitialized: boolean;
  hasPermissions: boolean;
  isLoading: boolean;
  error: string | null;
  metrics: HealthMetrics | null;
}

================
File: features/home/components/HomeScreen.tsx
================
import React, { useState } from 'react';
import { StyleSheet, View, ScrollView, RefreshControl } from 'react-native';
import { useTheme, Text, Surface, ActivityIndicator, IconButton } from 'react-native-paper';
import { StatusBar } from 'expo-status-bar';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import useHealthData from '../../health/hooks/useHealthData';
import { formatDistance, formatScore } from '../../../core/utils/formatting';
import { MetricCard } from './MetricCard';
import { MetricModal } from './MetricModal';
import { HealthMetrics } from '../../profile/types/health';
import { TabParamList } from '../../../navigation/types';
import { MeasurementSystem } from '../../../core/types/base';

// TODO: Replace with actual user profile management
const MOCK_PROFILE_ID = 'test_user_1';
// TODO: Make this configurable per user's preference
const DEFAULT_MEASUREMENT_SYSTEM: MeasurementSystem = 'imperial';

type MetricType = 'steps' | 'distance' | 'score';

interface ModalData {
  type: MetricType;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

type NavigationProp = NativeStackNavigationProp<TabParamList, 'Home'>;

export const HomeScreen: React.FC = () => {
  const theme = useTheme();
  const navigation = useNavigation<NavigationProp>();
  const { metrics, loading, error, refresh } = useHealthData(MOCK_PROFILE_ID);
  const [refreshing, setRefreshing] = React.useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [selectedMetric, setSelectedMetric] = useState<ModalData | null>(null);

  const onRefresh = React.useCallback(async () => {
    setRefreshing(true);
    await refresh();
    setRefreshing(false);
  }, [refresh]);

  const handleLeaderboardPress = () => {
    navigation.navigate('Leaderboard');
  };

  const handleMetricPress = (type: MetricType, metrics: HealthMetrics) => {
    let modalData: ModalData = {
      type,
      title: type.charAt(0).toUpperCase() + type.slice(1),
      value: type === 'distance' ? formatDistance(metrics[type], DEFAULT_MEASUREMENT_SYSTEM) : metrics[type].toString(),
      data: {
        labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        values: [0, 0, 0, 0, 0, 0, metrics[type]],
      },
    };

    setSelectedMetric(modalData);
    setModalVisible(true);
  };

  if (loading && !refreshing) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </Surface>
    );
  }

  if (error) {
    return (
      <Surface style={[styles.container, styles.centered]}>
        <Text variant="titleMedium" style={styles.errorText}>{error}</Text>
        <IconButton icon="refresh" onPress={refresh} />
      </Surface>
    );
  }

  return (
    <View style={styles.container}>
      <StatusBar style={theme.dark ? 'light' : 'dark'} />
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        <View style={styles.header}>
          <Text variant="headlineMedium" style={styles.title}>
            Health Dashboard
          </Text>
          <IconButton
            icon="trophy"
            mode="contained"
            onPress={handleLeaderboardPress}
            style={styles.leaderboardButton}
          />
        </View>

        <View style={styles.metricsContainer}>
          <MetricCard
            title="Steps"
            value={metrics?.steps?.toLocaleString() || '0'}
            icon="walk"
            metricType="steps"
            onPress={() => metrics && handleMetricPress('steps', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Distance"
            value={formatDistance(metrics?.distance || 0, DEFAULT_MEASUREMENT_SYSTEM)}
            icon="map-marker-distance"
            metricType="distance"
            onPress={() => metrics && handleMetricPress('distance', metrics)}
            loading={loading}
            error={error}
          />
          <MetricCard
            title="Score"
            value={formatScore(metrics?.score || 0)}
            icon="star"
            metricType="score"
            onPress={() => metrics && handleMetricPress('score', metrics)}
            loading={loading}
            error={error}
          />
        </View>

        {selectedMetric && (
          <MetricModal
            visible={modalVisible}
            onClose={() => setModalVisible(false)}
            title={selectedMetric?.title || ''}
            value={selectedMetric?.value || ''}
            data={selectedMetric?.data}
            additionalInfo={selectedMetric?.additionalInfo}
          />
        )}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  
  },
  content: {
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    marginBottom: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 16,
  },
  title: {
    fontWeight: 'bold',
  },
  leaderboardButton: {
    margin: 0,
  },
  metricsContainer: {
    width: '100%',
    alignItems: 'stretch',
    gap: 16,
  },
  scrollView: {
    flex: 1,
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
  },
});

================
File: features/home/components/MetricCard.tsx
================
import React from 'react';
import { StyleSheet, View } from 'react-native';
import { Surface, Text, TouchableRipple, useTheme, ActivityIndicator } from 'react-native-paper';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { getMetricColor, MetricColorKey } from '../../../theme';

interface MetricCardProps {
  title: string;
  value: string | number;
  icon: keyof typeof MaterialCommunityIcons.glyphMap;
  metricType: MetricColorKey;
  onPress?: () => void;
  loading?: boolean;
  error?: string | null;
}

export const MetricCard: React.FC<MetricCardProps> = ({
  title,
  value,
  icon,
  metricType,
  onPress,
  loading,
  error,
}) => {
  const theme = useTheme();
  const metricColor = getMetricColor(metricType);

  const renderContent = () => {
    if (loading) {
      return <ActivityIndicator size="small" color={metricColor} />;
    }

    if (error) {
      return <Text style={[styles.errorText, { color: theme.colors.error }]}>{error}</Text>;
    }

    return (
      <>
        <MaterialCommunityIcons name={icon} size={24} color={metricColor} />
        <Text variant="titleLarge" style={[styles.value, { color: theme.colors.onSurface }]}>
          {value}
        </Text>
        <Text variant="labelMedium" style={[styles.title, { color: theme.colors.onSurfaceVariant }]}>
          {title}
        </Text>
      </>
    );
  };

  return (
    <Surface
      style={[
        styles.container,
        {
          backgroundColor: theme.colors.surface,
          borderColor: theme.colors.surfaceVariant,
        },
      ]}
      elevation={1}
    >
      <View style={styles.innerContainer}>
        <TouchableRipple
          onPress={onPress}
          style={styles.touchable}
          rippleColor={metricColor}
          disabled={loading || !!error}
        >
          <>{renderContent()}</>
        </TouchableRipple>
      </View>
    </Surface>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: 8,
    borderRadius: 12,
    minHeight: 120,
    borderWidth: 1,
  },
  innerContainer: {
    flex: 1,
    overflow: 'hidden',
    borderRadius: 12,
  },
  touchable: {
    flex: 1,
    padding: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  value: {
    marginTop: 8,
    fontWeight: '600',
  },
  title: {
    marginTop: 4,
  },
  errorText: {
    textAlign: 'center',
    padding: 8,
  },
});

================
File: features/home/components/MetricModal.tsx
================
import React from 'react';
import { StyleSheet, View, Dimensions } from 'react-native';
import { Modal, Portal, Text, IconButton, Surface, useTheme } from 'react-native-paper';
import { LineChart } from 'react-native-chart-kit';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

interface MetricModalProps {
  visible: boolean;
  onClose: () => void;
  title: string;
  value: string | number;
  data?: {
    labels: string[];
    values: number[];
  };
  additionalInfo?: {
    label: string;
    value: string | number;
  }[];
}

export const MetricModal: React.FC<MetricModalProps> = ({
  visible,
  onClose,
  title,
  value,
  data,
  additionalInfo,
}) => {
  const theme = useTheme();
  const insets = useSafeAreaInsets();

  const chartConfig = {
    backgroundColor: theme.colors.surface,
    backgroundGradientFrom: theme.colors.surface,
    backgroundGradientTo: theme.colors.surface,
    decimalPlaces: 0,
    color: (opacity = 1) => theme.colors.primary,
    labelColor: (opacity = 1) => theme.colors.onSurface,
    style: {
      borderRadius: 16,
    },
    propsForDots: {
      r: '6',
      strokeWidth: '2',
      stroke: theme.colors.primary,
    },
  };

  return (
    <Portal>
      <Modal
        visible={visible}
        onDismiss={onClose}
        contentContainerStyle={[
          styles.modalContainer,
          { paddingBottom: insets.bottom },
          { backgroundColor: theme.colors.surface }
        ]}
      >
        <Surface style={styles.modalContent} elevation={0}>
          <IconButton
            icon="close"
            size={24}
            onPress={onClose}
            style={styles.closeButton}
          />

          <Text variant="headlineMedium" style={styles.modalTitle}>
            {title}
          </Text>
          <Text variant="displaySmall" style={[styles.modalValue, { color: theme.colors.primary }]}>
            {value}
          </Text>

          {data && data.values.length > 0 && (
            <View style={styles.chartContainer}>
              <LineChart
                data={{
                  labels: data.labels,
                  datasets: [{ data: data.values }],
                }}
                width={Dimensions.get('window').width - 48}
                height={220}
                chartConfig={chartConfig}
                bezier
                style={{
                  marginVertical: 8,
                  borderRadius: 16,
                }}
              />
            </View>
          )}

          {additionalInfo && additionalInfo.length > 0 && (
            <Surface style={styles.additionalInfoContainer} elevation={0}>
              {additionalInfo.map((info, index) => (
                <View key={index} style={styles.infoRow}>
                  <Text variant="labelLarge" style={{ color: theme.colors.onSurfaceVariant }}>
                    {info.label}
                  </Text>
                  <Text variant="bodyLarge" style={{ color: theme.colors.onSurface }}>
                    {info.value}
                  </Text>
                </View>
              ))}
            </Surface>
          )}
        </Surface>
      </Modal>
    </Portal>
  );
};

const styles = StyleSheet.create({
  modalContainer: {
    margin: 0,
    justifyContent: 'flex-end',
  },
  modalContent: {
    padding: 24,
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
  },
  closeButton: {
    position: 'absolute',
    right: 8,
    top: 8,
  },
  modalTitle: {
    marginTop: 8,
    marginBottom: 4,
  },
  modalValue: {
    marginBottom: 16,
  },
  chartContainer: {
    alignItems: 'center',
    marginVertical: 16,
  },
  additionalInfoContainer: {
    marginTop: 16,
    gap: 12,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
});

================
File: features/leaderboard/components/LeaderboardScreen.tsx
================
import React from 'react';
import { View, ScrollView, StyleSheet } from 'react-native';
import { Surface, Text, useTheme, Avatar, Divider } from 'react-native-paper';
import { formatScore } from '../../../core/utils/formatting';

interface LeaderboardEntry {
  id: string;
  name: string;
  score: number;
  rank: number;
}

interface LeaderboardItemProps {
  rank: number;
  name: string;
  score: number;
  isUser: boolean;
}

// Dummy data for the leaderboard
const DUMMY_DATA: LeaderboardEntry[] = [
  { id: '1', name: 'You', score: 85, rank: 1 },
  { id: '2', name: 'Sarah Johnson', score: 82, rank: 2 },
  { id: '3', name: 'Mike Chen', score: 79, rank: 3 },
  { id: '4', name: 'Emma Wilson', score: 76, rank: 4 },
  { id: '5', name: 'James Smith', score: 73, rank: 5 },
  { id: '6', name: 'Lisa Brown', score: 70, rank: 6 },
  { id: '7', name: 'David Lee', score: 68, rank: 7 },
  { id: '8', name: 'Anna Garcia', score: 65, rank: 8 },
  { id: '9', name: 'Tom Wilson', score: 62, rank: 9 },
  { id: '10', name: 'Rachel Kim', score: 60, rank: 10 },
];

const LeaderboardItem: React.FC<LeaderboardItemProps> = ({ rank, name, score, isUser }) => {
  const theme = useTheme();
  
  return (
    <Surface style={[styles.itemContainer, isUser && { backgroundColor: theme.colors.primaryContainer }]}>
      <View style={styles.rankContainer}>
        <Text style={[styles.rank, { color: theme.colors.primary }]}>{rank}</Text>
      </View>
      <View style={styles.userInfo}>
        <Avatar.Text size={40} label={name.charAt(0)} />
        <Text style={[styles.name, { marginLeft: 12 }]}>{name}</Text>
      </View>
      <View style={styles.scoreContainer}>
        <Text style={[styles.score, { color: theme.colors.primary }]}>{formatScore(score)}</Text>
      </View>
    </Surface>
  );
};

export const LeaderboardScreen: React.FC = () => {
  const theme = useTheme();

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <Surface style={[styles.headerContainer, { backgroundColor: theme.colors.surface }]}>
        <Text variant="headlineMedium" style={styles.title}>Leaderboard</Text>
        <Text variant="bodyMedium" style={{ color: theme.colors.onSurfaceVariant }}>
          Top Health Scores
        </Text>
      </Surface>
      
      <ScrollView style={styles.scrollView}>
        {DUMMY_DATA.map((item) => (
          <React.Fragment key={item.id}>
            <LeaderboardItem
              rank={item.rank}
              name={item.name}
              score={item.score}
              isUser={item.name === 'You'}
            />
            <Divider />
          </React.Fragment>
        ))}
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  headerContainer: {
    padding: 16,
    alignItems: 'center',
    elevation: 2,
  },
  title: {
    fontWeight: 'bold',
    marginBottom: 4,
  },
  scrollView: {
    flex: 1,
  },
  itemContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    height: 80,
  },
  rankContainer: {
    width: 40,
    alignItems: 'center',
  },
  rank: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  userInfo: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    marginLeft: 12,
  },
  name: {
    fontSize: 16,
    fontWeight: '500',
  },
  scoreContainer: {
    marginLeft: 'auto',
    paddingRight: 8,
  },
  score: {
    fontSize: 18,
    fontWeight: 'bold',
  },
});

================
File: features/profile/components/ProfileScreen.tsx
================
import React, { useState, useCallback } from 'react';
import { View, StyleSheet, ScrollView } from 'react-native';
import { TextInput, Button, Avatar, useTheme, HelperText } from 'react-native-paper';
import { StackNavigationProp } from '@react-navigation/stack';
import { useAuth } from '../../../context/AuthContext';
import { customLightTheme, customDarkTheme } from '../../../theme';

type RootStackParamList = {
  Profile: undefined;
  Settings: undefined;
  Login: undefined;
};

type ProfileScreenProps = {
  navigation: StackNavigationProp<RootStackParamList, 'Profile'>;
};

export const ProfileScreen: React.FC<ProfileScreenProps> = ({ navigation }) => {
  const { logout, user } = useAuth();
  const paperTheme = useTheme();
  const [displayName, setDisplayName] = useState(user?.displayName || '');
  const [loading, setLoading] = useState(false);
  const [editMode, setEditMode] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogout = useCallback(async () => {
    try {
      setLoading(true);
      await logout();
      // Navigation will be handled by the AuthContext
    } catch (err) {
      console.error('[ProfileScreen] Logout error:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
    } finally {
      setLoading(false);
    }
  }, [logout]);

  const handleProfileUpdate = useCallback(async () => {
    if (!displayName.trim()) {
      setError('Display name cannot be empty');
      return;
    }
    
    try {
      setLoading(true);
      setError(null);
      // TODO: Implement profile update
      setEditMode(false);
    } catch (err) {
      console.error('[ProfileScreen] Profile update error:', err);
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setLoading(false);
    }
  }, [displayName]);

  return (
    <View style={[styles.container, { backgroundColor: paperTheme.colors.background }]}>
      <ScrollView style={styles.content}>
        <View style={styles.avatarContainer}>
          <Avatar.Image
            size={100}
            source={{ uri: 'https://via.placeholder.com/100' }}
          />
        </View>

        <View style={styles.form}>
          {editMode ? (
            <>
              <TextInput
                label="Display Name"
                value={displayName}
                onChangeText={setDisplayName}
                mode="outlined"
                disabled={loading}
                error={!!error}
              />
              {error && <HelperText type="error">{error}</HelperText>}
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={handleProfileUpdate}
                  loading={loading}
                  disabled={loading}
                  style={styles.button}
                >
                  Save
                </Button>
                <Button
                  mode="outlined"
                  onPress={() => {
                    setEditMode(false);
                    setDisplayName(user?.displayName || '');
                    setError(null);
                  }}
                  disabled={loading}
                  style={styles.button}
                >
                  Cancel
                </Button>
              </View>
            </>
          ) : (
            <>
              <TextInput
                label="Display Name"
                value={user?.displayName || ''}
                disabled
                mode="outlined"
              />
              <TextInput
                label="Email"
                value={user?.email || ''}
                disabled
                mode="outlined"
              />
              <View style={styles.buttonContainer}>
                <Button
                  mode="contained"
                  onPress={() => setEditMode(true)}
                  style={styles.button}
                >
                  Edit Profile
                </Button>
                <Button
                  mode="outlined"
                  onPress={handleLogout}
                  loading={loading}
                  disabled={loading}
                  style={styles.button}
                >
                  Logout
                </Button>
              </View>
            </>
          )}
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  avatarContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  form: {
    gap: 16,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  button: {
    flex: 1,
    marginHorizontal: 4,
  },
});

================
File: features/profile/types/profile.ts
================
import { BaseEntity, Gender, BloodType, MeasurementSystem, PrivacyLevel } from '../../../core/types/base';

export interface Biometrics {
  height?: number;  // in centimeters
  weight?: number;  // in kilograms
  bloodType?: BloodType;
}

export interface Preferences {
  measurementSystem: MeasurementSystem;
  notifications: boolean;
  privacyLevel: PrivacyLevel;
  dailyGoals?: {
    steps?: number;
    sleep?: number;  // in minutes
    water?: number;  // in milliliters
  };
}

export interface Profile extends BaseEntity {
  firstName: string;
  lastName: string;
  dateOfBirth: Date;
  gender: Gender;
  biometrics: Biometrics;
  preferences: Preferences;
}

================
File: navigation/AppStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AppStackParamList } from './types';
import { TabNavigator } from './TabNavigator';
import { useTheme } from 'react-native-paper';

const Stack = createNativeStackNavigator<AppStackParamList>();

export const AppStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Stack.Screen 
        name="MainTabs" 
        component={TabNavigator}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

================
File: navigation/AuthStack.tsx
================
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AuthStackParamList } from './types';
import { useTheme } from 'react-native-paper';
import { Surface, Text, Button } from 'react-native-paper';
import { View, StyleSheet } from 'react-native';
import { useAuth } from '../context/AuthContext';

const Stack = createNativeStackNavigator<AuthStackParamList>();

// Temporary Login Screen
const LoginScreen = () => {
  const { login } = useAuth();
  const theme = useTheme();

  const handleLogin = async () => {
    try {
      // For testing, automatically log in
      await login('test_user_1');
    } catch (error) {
      console.error('Login error:', error);
    }
  };

  return (
    <Surface style={styles.screen}>
      <Text variant="headlineMedium" style={{ marginBottom: 24 }}>Welcome Back</Text>
      <Button mode="contained" onPress={handleLogin}>
        Login
      </Button>
    </Surface>
  );
};

// Temporary Register Screen
const RegisterScreen = () => {
  const theme = useTheme();
  
  return (
    <Surface style={styles.screen}>
      <Text variant="headlineMedium">Create Account</Text>
    </Surface>
  );
};

export const AuthStack = () => {
  const theme = useTheme();

  return (
    <Stack.Navigator
      screenOptions={{
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Stack.Screen 
        name="Login" 
        component={LoginScreen}
        options={{
          title: 'Login',
          headerShown: false,
        }}
      />
      <Stack.Screen 
        name="Register" 
        component={RegisterScreen}
        options={{
          title: 'Register',
          headerShown: false,
        }}
      />
    </Stack.Navigator>
  );
};

const styles = StyleSheet.create({
  screen: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

================
File: navigation/RootNavigator.tsx
================
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAuth } from '../context/AuthContext';
import { useApp } from '../context/AppContext';
import { Surface, ActivityIndicator } from 'react-native-paper';
import { AuthStack } from './AuthStack';
import { AppStack } from './AppStack';

const Stack = createNativeStackNavigator();

const LoadingScreen = () => (
  <Surface style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
    <ActivityIndicator size="large" />
  </Surface>
);

export const RootNavigator = () => {
  const { isAuthenticated, isLoading: authLoading } = useAuth();
  const { theme, isLoading: appLoading } = useApp();

  if (authLoading || appLoading) {
    return <LoadingScreen />;
  }

  return (
    <NavigationContainer theme={theme}>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {isAuthenticated ? (
          <Stack.Screen name="App" component={AppStack} />
        ) : (
          <Stack.Screen name="Auth" component={AuthStack} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

================
File: navigation/TabNavigator.tsx
================
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme } from 'react-native-paper';
import { HomeScreen } from '../features/home/components/HomeScreen';
import { LeaderboardScreen } from '../features/leaderboard/components/LeaderboardScreen';
import { ProfileScreen } from '../features/profile/components/ProfileScreen';

const Tab = createBottomTabNavigator();

export const TabNavigator = () => {
  const theme = useTheme();

  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.onSurfaceVariant,
        tabBarStyle: {
          backgroundColor: theme.colors.surface,
          borderTopColor: theme.colors.outline,
        },
        headerStyle: {
          backgroundColor: theme.colors.surface,
        },
        headerTintColor: theme.colors.onSurface,
        headerShadowVisible: false,
      }}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          title: 'Health Dashboard',
        }}
      />
      <Tab.Screen
        name="Leaderboard"
        component={LeaderboardScreen}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
      />
    </Tab.Navigator>
  );
};

================
File: navigation/types.ts
================
export type RootStackParamList = {
  Auth: undefined;
  App: undefined;
};

export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
};

export type AppStackParamList = {
  MainTabs: undefined;
};

export type TabParamList = {
  Home: undefined;
  Leaderboard: undefined;
  Profile: undefined;
};

================
File: theme/index.ts
================
import { MD3DarkTheme, MD3LightTheme } from 'react-native-paper';
import { MD3Colors } from 'react-native-paper/lib/typescript/types';

// Custom colors for metrics
const metricColors = {
  steps: '#4CAF50',      // Green
  distance: '#2196F3',   // Blue
  score: '#FFC107',      // Amber
  calories: '#FF5722',   // Deep Orange
  sleep: '#9C27B0',      // Purple
};

export const lightColors: MD3Colors = {
  ...MD3LightTheme.colors,
  primary: '#006A6A',
  onPrimary: '#FFFFFF',
  primaryContainer: '#6FF7F7',
  onPrimaryContainer: '#002020',
  secondary: '#4A6363',
  onSecondary: '#FFFFFF',
  secondaryContainer: '#CCE8E7',
  onSecondaryContainer: '#051F1F',
  background: '#FAFDFC',
  surface: '#FAFDFC',
  surfaceVariant: '#DAE5E4',
  onSurfaceVariant: '#3F4948',
  error: '#BA1A1A',
  onError: '#FFFFFF',
  errorContainer: '#FFDAD6',
  onErrorContainer: '#410002',
};

export const darkColors: MD3Colors = {
  ...MD3DarkTheme.colors,
  primary: '#4CDADA',
  onPrimary: '#003737',
  primaryContainer: '#004F4F',
  onPrimaryContainer: '#6FF7F7',
  secondary: '#B0CCCC',
  onSecondary: '#1B3434',
  secondaryContainer: '#324B4B',
  onSecondaryContainer: '#CCE8E7',
  background: '#191C1C',
  surface: '#191C1C',
  surfaceVariant: '#3F4948',
  onSurfaceVariant: '#BEC9C8',
  error: '#FFB4AB',
  onError: '#690005',
  errorContainer: '#93000A',
  onErrorContainer: '#FFDAD6',
};

export const lightTheme = {
  ...MD3LightTheme,
  colors: lightColors,
  metrics: metricColors,
};

export const darkTheme = {
  ...MD3DarkTheme,
  colors: darkColors,
  metrics: metricColors,
};

// Create a custom theme that combines MD3Theme and NavigationTheme
export const customLightTheme = {
  ...MD3LightTheme,
  colors: {
    ...lightColors,
    // Add required navigation theme colors
    card: lightColors.surface,
    text: lightColors.onSurface,
    border: lightColors.outline,
    notification: lightColors.error,
  },
};

export const customDarkTheme = {
  ...MD3DarkTheme,
  colors: {
    ...darkColors,
    // Add required navigation theme colors
    card: darkColors.surface,
    text: darkColors.onSurface,
    border: darkColors.outline,
    notification: darkColors.error,
  },
};

export type AppTheme = typeof customLightTheme;
export type MetricColorKey = keyof typeof metricColors;

// Helper function to get metric color
export const getMetricColor = (metricType: MetricColorKey): string => {
  return metricColors[metricType] || metricColors.score;
};
