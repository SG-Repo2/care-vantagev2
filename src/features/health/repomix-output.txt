This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-23T21:38:24.808Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
hooks/
  useHealthData.ts
services/
  platforms/
    AppleHealthService.ts
    GoogleHealthService.ts
    MockHealthService.ts
  base.ts
  factory.ts
  platform.ts
  types.ts
types/
  health.ts

================================================================
Repository Files
================================================================

================
File: hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { HealthMetrics } from '../types/health';
import { HealthServiceFactory } from '../services/factory';
import AppleHealthKit from 'react-native-health';

const { Permissions } = AppleHealthKit.Constants;

const defaultPermissions = {
  permissions: {
    read: [
      Permissions.Steps,
      Permissions.DistanceWalkingRunning,
    ],
    write: [],
  },
};

const healthService = HealthServiceFactory.getService();

const useHealthData = (profileId: string) => {
  const [metrics, setMetrics] = useState<HealthMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const initialize = useCallback(async () => {
    try {
      const initialized = await healthService.initialize(defaultPermissions);
      if (initialized) {
        const permissions = await healthService.hasPermissions();
        setHasPermission(permissions);
        return permissions;
      }
      return false;
    } catch (err) {
      console.error('Health service initialization error:', err);
      setError('Failed to initialize health service');
      return false;
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions) return;

    setLoading(true);
    setError(null);

    try {
      // Wrap HealthKit operations in a background task
      const newMetrics = await new Promise<HealthMetrics>((resolve, reject) => {
        requestAnimationFrame(async () => {
          try {
            const metrics = await healthService.getMetrics();
            resolve(metrics);
          } catch (error) {
            reject(error);
          }
        });
      });

      setMetrics({
        ...newMetrics,
        profileId,
      } as HealthMetrics);
    } catch (err) {
      console.error('Error fetching health data:', err);
      setError('Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions, profileId]);

  const refresh = useCallback(async () => {
    await fetchHealthData();
  }, [fetchHealthData]);

  useEffect(() => {
    const setupHealthData = async () => {
      const initialized = await initialize();
      if (initialized) {
        await fetchHealthData();
      }
    };

    setupHealthData();
  }, [initialize, fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    refresh,
    hasPermissions,
  };
};

export default useHealthData;

================
File: services/platforms/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
} from 'react-native-health';
import { Platform, InteractionManager } from 'react-native';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class AppleHealthService extends BaseHealthService {
  protected source = 'apple_health' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return new Promise((resolve) => {
      // Ensure initialization happens on main thread
      Platform.select({
        ios: () => {
          InteractionManager.runAfterInteractions(() => {
            AppleHealthKit.initHealthKit(config as HealthKitPermissions, (error: string) => {
              // Ensure callback executes on main thread
              requestAnimationFrame(() => {
                resolve(!error);
              });
            });
          });
        },
        default: () => resolve(false),
      })();
    });
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  protected async doHasPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getStepCount(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value);
          });
        });
      });
    });
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getDistanceWalkingRunning(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value / 1000); // Convert to kilometers
          });
        });
      });
    });
  }
}

================
File: services/platforms/GoogleHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class GoogleHealthService extends BaseHealthService {
  protected source = 'google_fit' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    // TODO: Implement Google Fit initialization
    return false;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions request
    return false;
  }

  protected async doHasPermissions(): Promise<boolean> {
    // TODO: Implement Google Fit permissions check
    return false;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    throw new Error('Google Fit implementation not yet available');
  }
}

================
File: services/platforms/MockHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class MockHealthService extends BaseHealthService {
  protected source = 'manual' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return true;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    // Return a random number of steps between 5000 and 15000
    return Math.floor(Math.random() * (15000 - 5000 + 1)) + 5000;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    // Return a random distance between 3 and 10 kilometers
    return Number((Math.random() * (10 - 3) + 3).toFixed(2));
  }
}

================
File: services/base.ts
================
import { HealthService, HealthServiceConfig } from './types';
import { HealthMetrics } from '../types/health';
import { HealthScoring } from '../../../core/utils/scoring';
import { DataSource } from '../../../core/types/base';

export abstract class BaseHealthService implements HealthService {
  protected initialized = false;
  protected abstract source: DataSource;

  async initialize(config: HealthServiceConfig): Promise<boolean> {
    if (this.initialized) return true;
    const success = await this.doInitialize(config);
    this.initialized = success;
    return success;
  }

  protected abstract doInitialize(config: HealthServiceConfig): Promise<boolean>;

  async requestPermissions(): Promise<boolean> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    return this.doRequestPermissions();
  }

  protected abstract doRequestPermissions(): Promise<boolean>;

  async hasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    return this.doHasPermissions();
  }

  protected abstract doHasPermissions(): Promise<boolean>;

  async getMetrics(date: Date = new Date()): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }

    const [steps, distance] = await Promise.all([
      this.getDailySteps(date),
      this.getDailyDistance(date),
    ]);

    const now = new Date();
    const id = `metrics_${now.getTime()}`;

    const metrics: HealthMetrics = {
      id,
      profileId: '', // Set from the calling context
      date: date.toISOString(),
      steps,
      distance,
      score: 0,
      source: this.source,
      createdAt: now,
      updatedAt: now,
    };

    const score = HealthScoring.calculateScore(metrics);
    metrics.score = score.overall;

    return metrics;
  }

  abstract getDailySteps(date?: Date): Promise<number>;
  abstract getDailyDistance(date?: Date): Promise<number>;
}

================
File: services/factory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './types';
import { AppleHealthService } from './platforms/AppleHealthService';
import { GoogleHealthService } from './platforms/GoogleHealthService';
import { MockHealthService } from './platforms/MockHealthService';
import { getCurrentPlatform } from './platform';

export class HealthServiceFactory {
  static getService(): HealthService {
    const currentPlatform = getCurrentPlatform();
    if (currentPlatform.id === 'apple_health') {
      return new AppleHealthService();
    }
    if (currentPlatform.id === 'google_fit') {
      return new GoogleHealthService();
    }
    return new MockHealthService();
  }
}

================
File: services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

const appleHealthPlatform: HealthPlatform = {
  id: 'apple_health',
  name: 'Apple Health',
  version: '1.0.0',
  type: 'apple_health'
};

const googleFitPlatform: HealthPlatform = {
  id: 'google_fit',
  name: 'Google Fit',
  version: '1.0.0',
  type: 'google_fit'
};

const manualPlatform: HealthPlatform = {
  id: 'manual',
  name: 'Manual Entry',
  version: '1.0.0',
  type: 'manual'
};

export const getCurrentPlatform = (): HealthPlatform => {
  if (Platform.OS === 'ios') {
    return appleHealthPlatform;
  }
  
  if (Platform.OS === 'android') {
    return googleFitPlatform;
  }
  
  return manualPlatform;
};

================
File: services/types.ts
================
import { HealthMetrics } from '../types/health';

export interface HealthServiceConfig {
  permissions: {
    read: string[];
    write: string[];
  };
  options?: Record<string, any>;
}

export interface HealthService {
  initialize(config: HealthServiceConfig): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  hasPermissions(): Promise<boolean>;
  getMetrics(date?: Date): Promise<HealthMetrics>;
  getDailySteps(date?: Date): Promise<number>;
  getDailyDistance(date?: Date): Promise<number>;
}

================
File: types/health.ts
================
import { DataSource } from '../../../core/types/base';

export interface HealthScore {
  overall: number;
  categories: {
    steps: number;
    distance: number;
  };
  dailyVictory: boolean;
}

export interface HealthMetrics {
  id: string;
  profileId: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
  source: DataSource;
  createdAt: Date;
  updatedAt: Date;
}

export type MetricType = 'steps' | 'distance' | 'score';

export interface HealthState {
  isInitialized: boolean;
  hasPermissions: boolean;
  isLoading: boolean;
  error: string | null;
  metrics: HealthMetrics | null;
}
