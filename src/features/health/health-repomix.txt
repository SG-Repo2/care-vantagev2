This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-03T23:06:47.977Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
hooks/
  useHealthData.ts
services/
  platforms/
    AppleHealthService.ts
    GHealthConnectService.ts
    GoogleHealthService.ts
    MockHealthService.ts
  base.ts
  factory.ts
  healthMetricsService.ts
  NativeHealthConnect.ts
  platform.ts
  types.ts
types/
  health.ts

================================================================
Repository Files
================================================================

================
File: hooks/useHealthData.ts
================
import { useEffect, useState, useCallback } from 'react';
import { HealthMetrics, WeeklyMetrics } from '../types/health';
import { HealthServiceFactory } from '../services/factory';
import { HealthService } from '../services/types';
import AppleHealthKit from 'react-native-health';
import { getCurrentWeekStart } from '../../../core/constants/metrics';
import healthMetricsService from '../services/healthMetricsService';

const { Permissions } = AppleHealthKit.Constants;

const defaultPermissions = {
  permissions: {
    read: [
      Permissions.Steps,
      Permissions.DistanceWalkingRunning,
    ],
    write: [],
  },
};

const useHealthData = (profileId: string) => {
  const [healthService, setHealthService] = useState<HealthService | null>(null);
  const [metrics, setMetrics] = useState<HealthMetrics & WeeklyMetrics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasPermissions, setHasPermission] = useState(false);

  const initialize = useCallback(async () => {
    try {
      const service = await HealthServiceFactory.getService();
      setHealthService(service);
      
      const initialized = await service.initialize(defaultPermissions);
      if (initialized) {
        const permissions = await service.hasPermissions();
        setHasPermission(permissions);
        return permissions;
      }
      return false;
    } catch (err) {
      console.error('Health service initialization error:', err);
      setError('Failed to initialize health service');
      return false;
    }
  }, []);

  const fetchHealthData = useCallback(async () => {
    if (!hasPermissions || !healthService) return;

    setLoading(true);
    setError(null);

    try {
      const [metrics, weeklySteps] = await Promise.all([
        healthService.getMetrics(),
        healthService.getWeeklySteps(getCurrentWeekStart())
      ]);

      // Only save metrics to Supabase if we have a valid UUID
      if (profileId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(profileId)) {
        await healthMetricsService.saveMetrics({
          user_id: profileId,
          date: new Date().toISOString().split('T')[0],
          steps: metrics.steps,
          distance: metrics.distance,
          score: metrics.score
        });
      }

      setMetrics({
        ...metrics,
        profileId,
        weeklySteps,
        weekStartDate: getCurrentWeekStart()
      });
    } catch (err) {
      console.error('Error fetching health data:', err);
      setError('Failed to fetch health data');
    } finally {
      setLoading(false);
    }
  }, [hasPermissions, profileId]);

  const refresh = useCallback(async () => {
    await fetchHealthData();
  }, [fetchHealthData]);

  useEffect(() => {
    const setupHealthData = async () => {
      const initialized = await initialize();
      if (initialized) {
        await fetchHealthData();
      }
    };

    setupHealthData();
  }, [initialize, fetchHealthData]);

  return {
    metrics,
    loading,
    error,
    refresh,
    hasPermissions,
  };
};

export default useHealthData;

================
File: services/platforms/AppleHealthService.ts
================
import AppleHealthKit, {
  HealthInputOptions,
  HealthKitPermissions,
} from 'react-native-health';
import { Platform, InteractionManager } from 'react-native';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class AppleHealthService extends BaseHealthService {
  protected source = 'apple_health' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return new Promise((resolve) => {
      // Ensure initialization happens on main thread
      Platform.select({
        ios: () => {
          InteractionManager.runAfterInteractions(() => {
            AppleHealthKit.initHealthKit(config as HealthKitPermissions, (error: string) => {
              // Ensure callback executes on main thread
              requestAnimationFrame(() => {
                resolve(!error);
              });
            });
          });
        },
        default: () => resolve(false),
      })();
    });
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  protected async doHasPermissions(): Promise<boolean> {
    return new Promise((resolve) => {
      InteractionManager.runAfterInteractions(() => {
        resolve(true);
      });
    });
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getStepCount(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value);
          });
        });
      });
    });
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    return new Promise((resolve, reject) => {
      const options: HealthInputOptions = {
        date: date.toISOString(),
      };
      
      InteractionManager.runAfterInteractions(() => {
        AppleHealthKit.getDistanceWalkingRunning(options, (err, results) => {
          requestAnimationFrame(() => {
            if (err) reject(err);
            else resolve(results.value / 1000); // Convert to kilometers
          });
        });
      });
    });
  }
}

================
File: services/platforms/GHealthConnectService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';
import { Platform } from 'react-native';
import NativeHealthConnect from '../NativeHealthConnect';

export class GHealthConnectService extends BaseHealthService {
  protected source = 'health_connect' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    if (Platform.OS !== 'android') return false;

    try {
      const availability = await NativeHealthConnect.isAvailable();
      if (!availability) {
        console.warn('Health Connect is not available on this device');
        return false;
      }
      
      this.initialized = true;
      return true;
    } catch (error) {
      console.error('Health Connect initialization error:', error);
      return false;
    }
  }

  protected async doRequestPermissions(): Promise<boolean> {
    if (!this.initialized) return false;

    try {
      return await NativeHealthConnect.requestPermissions([
        'android.permission.health.READ_STEPS',
        'android.permission.health.READ_DISTANCE'
      ]);
    } catch (error) {
      console.error('Health Connect permission request error:', error);
      return false;
    }
  }

  protected async doHasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    
    try {
      // For now just attempt to read steps as a permissions check
      const now = new Date();
      await this.getDailySteps(now);
      return true;
    } catch (error) {
      return false;
    }
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      const steps = await NativeHealthConnect.getDailySteps(
        startTime.getTime(),
        endTime.getTime()
      );
      return steps || 0; // Return 0 if no data available
    } catch (error) {
      console.error('Error reading steps from Health Connect:', error);
      return 0; // Return 0 on error
    }
  }

  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    if (!this.initialized) throw new Error('Health Connect not initialized');

    const startTime = new Date(date);
    startTime.setHours(0, 0, 0, 0);
    const endTime = new Date(date);
    endTime.setHours(23, 59, 59, 999);

    try {
      return await NativeHealthConnect.getDailyDistance(
        startTime.getTime(),
        endTime.getTime()
      );
    } catch (error) {
      console.error('Error reading distance from Health Connect:', error);
      throw error;
    }
  }
}

================
File: services/platforms/GoogleHealthService.ts
================
import { Platform, NativeModules } from 'react-native';
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

const { NativeHealthConnect } = NativeModules;

export class GoogleHealthService extends BaseHealthService {
  protected source = 'health_connect' as const;
  protected config: HealthServiceConfig | null = null;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    if (Platform.OS !== 'android') {
      return false;
    }

    this.config = config;
    try {
      const isAvailable = await NativeHealthConnect.isAvailable();
      if (!isAvailable) {
        console.warn('Health Connect is not available on this device');
        return false;
      }
      return true;
    } catch (error) {
      console.error('Failed to initialize Health Connect:', error);
      return false;
    }
  }

  protected async doRequestPermissions(): Promise<boolean> {
    if (Platform.OS !== 'android' || !this.config) {
      return false;
    }

    try {
      const permissions = (this.config.permissions?.read || []) as string[];
      const granted = await NativeHealthConnect.requestPermissions(permissions);
      return granted;
    } catch (error) {
      console.error('Failed to request Health Connect permissions:', error);
      return false;
    }
  }

  protected async doHasPermissions(): Promise<boolean> {
    if (Platform.OS !== 'android' || !this.config) {
      return false;
    }

    try {
      const permissions = (this.config.permissions?.read || []) as string[];
      const hasPermissions = await NativeHealthConnect.hasPermissions(permissions);
      return hasPermissions;
    } catch (error) {
      console.error('Failed to check Health Connect permissions:', error);
      return false;
    }
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    if (Platform.OS !== 'android') {
      return 0;
    }

    try {
      const startTime = new Date(date);
      startTime.setHours(0, 0, 0, 0);
      const endTime = new Date(date);
      endTime.setHours(23, 59, 59, 999);

      const steps = await NativeHealthConnect.getSteps(
        startTime.toISOString(),
        endTime.toISOString()
      );
      return steps;
    } catch (error) {
      console.error('Failed to get steps from Health Connect:', error);
      return 0;
    }
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    if (Platform.OS !== 'android') {
      return 0;
    }

    try {
      const startTime = new Date(date);
      startTime.setHours(0, 0, 0, 0);
      const endTime = new Date(date);
      endTime.setHours(23, 59, 59, 999);

      const distance = await NativeHealthConnect.getDistance(
        startTime.toISOString(),
        endTime.toISOString()
      );
      return distance / 1000; // Convert to kilometers
    } catch (error) {
      console.error('Failed to get distance from Health Connect:', error);
      return 0;
    }
  }
}

================
File: services/platforms/MockHealthService.ts
================
import { HealthServiceConfig } from '../types';
import { BaseHealthService } from '../base';

export class MockHealthService extends BaseHealthService {
  protected source = 'manual' as const;

  protected async doInitialize(config: HealthServiceConfig): Promise<boolean> {
    return true;
  }

  protected async doRequestPermissions(): Promise<boolean> {
    return true;
  }

  protected async doHasPermissions(): Promise<boolean> {
    return true;
  }

  async getDailySteps(date: Date = new Date()): Promise<number> {
    // Return a random number of steps between 5000 and 15000
    return Math.floor(Math.random() * (15000 - 5000 + 1)) + 5000;
  }

  async getDailyDistance(date: Date = new Date()): Promise<number> {
    // Return a random distance between 3 and 10 kilometers
    return Number((Math.random() * (10 - 3) + 3).toFixed(2));
  }
}

================
File: services/base.ts
================
import { HealthService, HealthServiceConfig } from './types';
import { HealthMetrics } from '../types/health';
import { HealthScoring } from '../../../core/utils/scoring';
import { DataSource } from '../../../core/types/base';

export abstract class BaseHealthService implements HealthService {
  protected initialized = false;
  protected abstract source: DataSource;

  async initialize(config: HealthServiceConfig): Promise<boolean> {
    if (this.initialized) return true;
    const success = await this.doInitialize(config);
    this.initialized = success;
    return success;
  }

  protected abstract doInitialize(config: HealthServiceConfig): Promise<boolean>;

  async requestPermissions(): Promise<boolean> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    return this.doRequestPermissions();
  }

  protected abstract doRequestPermissions(): Promise<boolean>;

  async hasPermissions(): Promise<boolean> {
    if (!this.initialized) return false;
    return this.doHasPermissions();
  }

  protected abstract doHasPermissions(): Promise<boolean>;

  async getMetrics(date: Date = new Date()): Promise<HealthMetrics> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }

    const [steps, distance] = await Promise.all([
      this.getDailySteps(date),
      this.getDailyDistance(date),
    ]);

    const now = new Date();
    const id = `metrics_${now.getTime()}`;

    const metrics: HealthMetrics = {
      id,
      profileId: '', // Set from the calling context
      date: date.toISOString(),
      steps,
      distance,
      score: 0,
      source: this.source,
      createdAt: now,
      updatedAt: now,
    };

    const score = HealthScoring.calculateScore(metrics);
    metrics.score = score.overall;

    return metrics;
  }

  abstract getDailySteps(date?: Date): Promise<number>;
  abstract getDailyDistance(date?: Date): Promise<number>;
  
  async getWeeklySteps(startDate: Date): Promise<number[]> {
    if (!this.initialized) {
      throw new Error('Health service not initialized');
    }
    
    const weeklySteps: number[] = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < 7; i++) {
      try {
        const steps = await this.getDailySteps(currentDate);
        weeklySteps.push(steps);
      } catch (error) {
        console.error(`Error reading steps for ${currentDate.toISOString()}:`, error);
        weeklySteps.push(0);
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return weeklySteps;
  }
}

================
File: services/factory.ts
================
import { Platform } from 'react-native';
import { HealthService } from './types';
import { AppleHealthService } from './platforms/AppleHealthService';
import { GHealthConnectService } from './platforms/GHealthConnectService';
import { MockHealthService } from './platforms/MockHealthService';
import { getCurrentPlatform } from './platform';

export class HealthServiceFactory {
  static async getService(): Promise<HealthService> {
    const currentPlatform = await getCurrentPlatform();
    
    switch (currentPlatform.id) {
      case 'apple_health':
        return new AppleHealthService();
      case 'health_connect':
        return new GHealthConnectService();
      default:
        return new MockHealthService();
    }
  }
}

================
File: services/healthMetricsService.ts
================
import { supabase } from '../../../utils/supabase';

interface HealthMetricsData {
  user_id: string;
  date: string;
  steps: number;
  distance: number;
  score?: number; // Optional since we'll calculate it
}

interface UserProfile {
  id: string;
  display_name: string;
  photo_url: string;
  settings: {
    privacyLevel: string;
    measurementSystem: string;
  };
}

interface LeaderboardEntry {
  user_id: string;
  steps: number;
  distance: number;
  score: number;
  users: UserProfile[];
}

interface FormattedLeaderboardEntry {
  user_id: string;
  steps: number;
  distance: number;
  score: number;
  user: UserProfile;
}

class HealthMetricsService {
  private static instance: HealthMetricsService;

  private constructor() {}

  public static getInstance(): HealthMetricsService {
    if (!HealthMetricsService.instance) {
      HealthMetricsService.instance = new HealthMetricsService();
    }
    return HealthMetricsService.instance;
  }

  private calculateScore(steps: number, distance: number): number {
    // Base score calculation:
    // - Steps: 50% weight (10,000 steps = 50 points)
    // - Distance: 50% weight (5km = 50 points)
    const stepScore = Math.min(50, (steps / 10000) * 50);
    const distanceScore = Math.min(50, (distance / 5) * 50);
    
    // Round to nearest integer
    return Math.round(stepScore + distanceScore);
  }

  public async saveMetrics(metrics: HealthMetricsData): Promise<void> {
    const score = this.calculateScore(metrics.steps, metrics.distance);

    const { error } = await supabase
      .from('health_metrics')
      .upsert([{
        ...metrics,
        score,
        updated_at: new Date().toISOString()
      }], {
        onConflict: 'user_id,date'
      });

    if (error) throw error;
  }

  public async getLeaderboard(date: string): Promise<FormattedLeaderboardEntry[]> {
    const { data, error } = await supabase
      .from('health_metrics')
      .select(`
        user_id,
        steps,
        distance,
        score,
        users (
          id,
          display_name,
          photo_url,
          settings
        )
      `)
      .eq('date', date)
      .order('score', { ascending: false })
      .limit(100); // Limit to top 100 users for performance

    if (error) throw error;
    
    // Filter and transform the data
    return (data || [])
      .filter(entry => 
        entry.users?.[0]?.settings?.privacyLevel !== 'private' &&
        entry.users?.[0]?.display_name &&
        entry.steps !== null &&
        entry.distance !== null &&
        entry.score !== null
      )
      .map(entry => ({
        user_id: entry.user_id,
        steps: entry.steps,
        distance: entry.distance,
        score: entry.score,
        user: entry.users[0]
      }));
  }

  public async getUserMetrics(userId: string, date: string): Promise<HealthMetricsData | null> {
    const { data, error } = await supabase
      .from('health_metrics')
      .select('*')
      .eq('user_id', userId)
      .eq('date', date)
      .single();

    if (error) {
      if (error.code === 'PGRST116') { // Record not found
        return null;
      }
      throw error;
    }

    return data;
  }
}

export default HealthMetricsService.getInstance();

================
File: services/NativeHealthConnect.ts
================
import { NativeModules } from 'react-native';

const { HealthConnectModule } = NativeModules;

if (!HealthConnectModule) {
  throw new Error(
    'HealthConnectModule is not available. Did you properly link the native module?'
  );
}

interface NativeHealthConnectInterface {
  isAvailable(): Promise<boolean>;
  requestPermissions(permissions: string[]): Promise<boolean>;
  getDailySteps(startTime: number, endTime: number): Promise<number>;
  getDailyDistance(startTime: number, endTime: number): Promise<number>;
}

const NativeHealthConnect: NativeHealthConnectInterface = {
  isAvailable: HealthConnectModule.isAvailable,
  requestPermissions: HealthConnectModule.requestPermissions,
  getDailySteps: HealthConnectModule.getDailySteps,
  getDailyDistance: HealthConnectModule.getDailyDistance,
};

export default NativeHealthConnect;

================
File: services/platform.ts
================
import { Platform } from 'react-native';
import { DataSource } from '../../../core/types/base';

export interface HealthPlatform {
  id: string;
  name: string;
  version: string;
  type: DataSource;
}

const appleHealthPlatform: HealthPlatform = {
  id: 'apple_health',
  name: 'Apple Health',
  version: '1.0.0',
  type: 'apple_health'
};

const healthConnectPlatform: HealthPlatform = {
  id: 'health_connect',
  name: 'Health Connect',
  version: '1.0.0',
  type: 'health_connect'
};

const manualPlatform: HealthPlatform = {
  id: 'manual',
  name: 'Manual Entry',
  version: '1.0.0',
  type: 'manual'
};

declare const HealthConnectClient: {
  isAvailable(): Promise<boolean>;
};

export const getCurrentPlatform = async (): Promise<HealthPlatform> => {
  if (Platform.OS === 'ios') {
    return appleHealthPlatform;
  }
  
  if (Platform.OS === 'android') {
    try {
      const isHealthConnectAvailable = await HealthConnectClient.isAvailable();
      if (isHealthConnectAvailable) {
        return healthConnectPlatform;
      }
    } catch (error) {
      console.warn('Error checking Health Connect availability:', error);
    }
    return manualPlatform;
  }
  
  return manualPlatform;
};

================
File: services/types.ts
================
import { HealthMetrics } from '../types/health';

export interface HealthServiceConfig {
  permissions: {
    read: string[];
    write: string[];
  };
  options?: Record<string, any>;
}

export interface HealthService {
  initialize(config: HealthServiceConfig): Promise<boolean>;
  requestPermissions(): Promise<boolean>;
  hasPermissions(): Promise<boolean>;
  getMetrics(date?: Date): Promise<HealthMetrics>;
  getDailySteps(date?: Date): Promise<number>;
  getDailyDistance(date?: Date): Promise<number>;
  getWeeklySteps(startDate: Date): Promise<number[]>;
}

================
File: types/health.ts
================
import { DataSource } from '../../../core/types/base';

export interface HealthScore {
  overall: number;
  categories: {
    steps: number;
    distance: number;
  };
  dailyVictory: boolean;
  bonusPoints: number;
}

export interface HealthMetrics {
  id: string;
  profileId: string;
  date: string;
  steps: number;
  distance: number;
  score: number;
  source: DataSource;
  createdAt: Date;
  updatedAt: Date;
}

export interface WeeklyMetrics {
  weeklySteps: number[];
  weekStartDate: Date;
}

export type MetricType = 'steps' | 'distance' | 'score';

export interface HealthState {
  isInitialized: boolean;
  hasPermissions: boolean;
  isLoading: boolean;
  error: string | null;
  metrics: HealthMetrics | null;
}
