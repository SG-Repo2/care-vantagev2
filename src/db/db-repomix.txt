This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-03T23:09:21.273Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
migrations/
  01_create_base_schema.sql
  01_update_users_rls.sql
  02_add_leaderboard_tables.sql
  03_update_leaderboard_policies.sql
  04_grant_leaderboard_function_permissions.sql

================================================================
Repository Files
================================================================

================
File: migrations/01_create_base_schema.sql
================
-- Create users table if not exists
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    display_name TEXT,
    photo_url TEXT,
    settings JSONB DEFAULT '{
        "measurementSystem": "metric",
        "notifications": true,
        "privacyLevel": "private",
        "dailyGoals": {
            "steps": 10000,
            "sleep": 480,
            "water": 2000
        }
    }'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create health_metrics table if not exists
CREATE TABLE IF NOT EXISTS health_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    steps INTEGER NOT NULL DEFAULT 0,
    distance NUMERIC(10,2) NOT NULL DEFAULT 0,
    score INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, date)
);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_health_metrics_updated_at ON health_metrics;
CREATE TRIGGER update_health_metrics_updated_at
    BEFORE UPDATE ON health_metrics
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_health_metrics_user_id ON health_metrics(user_id);
CREATE INDEX IF NOT EXISTS idx_health_metrics_date ON health_metrics(date);
CREATE INDEX IF NOT EXISTS idx_health_metrics_score ON health_metrics(score DESC);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- Enable Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE health_metrics ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for users table
CREATE POLICY "Users can read all profiles"
    ON users FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Users can update their own profile"
    ON users FOR UPDATE
    TO authenticated
    USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
    ON users FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = id);

-- Create RLS policies for health_metrics table
CREATE POLICY "Users can read their own health metrics"
    ON health_metrics FOR SELECT
    TO authenticated
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own health metrics"
    ON health_metrics FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own health metrics"
    ON health_metrics FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Create function to calculate user rank
CREATE OR REPLACE FUNCTION get_user_rank(user_uuid UUID, target_date DATE)
RETURNS INTEGER AS $$
DECLARE
    user_rank INTEGER;
BEGIN
    SELECT rank
    INTO user_rank
    FROM (
        SELECT user_id, 
               RANK() OVER (ORDER BY score DESC) as rank
        FROM health_metrics
        WHERE date = target_date
    ) rankings
    WHERE user_id = user_uuid;
    
    RETURN user_rank;
END;
$$ LANGUAGE plpgsql;

================
File: migrations/01_update_users_rls.sql
================
DO $$
BEGIN
    -- Only enable RLS if it's not already enabled
    IF NOT EXISTS (
        SELECT 1
        FROM pg_tables
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND rowsecurity = true
    ) THEN
        ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
    END IF;

    -- Create policies only if they don't exist
    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can view own record'
    ) THEN
        CREATE POLICY "Users can view own record"
        ON public.users FOR SELECT
        USING (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can update own record'
    ) THEN
        CREATE POLICY "Users can update own record"
        ON public.users FOR UPDATE
        USING (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Users can insert own record'
    ) THEN
        CREATE POLICY "Users can insert own record"
        ON public.users FOR INSERT
        WITH CHECK (auth.uid() = id);
    END IF;

    IF NOT EXISTS (
        SELECT 1
        FROM pg_policies
        WHERE schemaname = 'public'
        AND tablename = 'users'
        AND policyname = 'Service role can manage all records'
    ) THEN
        CREATE POLICY "Service role can manage all records"
        ON public.users
        USING (auth.role() = 'service_role');
    END IF;
END
$$;

-- Ensure permissions are granted
GRANT ALL ON public.users TO authenticated;
GRANT ALL ON public.users TO service_role;

================
File: migrations/02_add_leaderboard_tables.sql
================
-- Enable Row Level Security
ALTER TABLE health_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Create policies for health_metrics table
CREATE POLICY "Users can read their own health metrics"
ON health_metrics
FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own health metrics"
ON health_metrics
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own health metrics"
ON health_metrics
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Create policies for users table
CREATE POLICY "Users can read all profiles"
ON users
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Users can update their own profile"
ON users
FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can insert their own profile"
ON users
FOR INSERT
WITH CHECK (auth.uid() = id);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_health_metrics_user_id ON health_metrics(user_id);
CREATE INDEX IF NOT EXISTS idx_health_metrics_date ON health_metrics(date);
CREATE INDEX IF NOT EXISTS idx_health_metrics_score ON health_metrics(score);

-- Add foreign key constraint if not exists
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_name = 'health_metrics_user_id_fkey'
    ) THEN
        ALTER TABLE health_metrics
        ADD CONSTRAINT health_metrics_user_id_fkey
        FOREIGN KEY (user_id)
        REFERENCES users(id)
        ON DELETE CASCADE;
    END IF;
END $$;

-- Add default settings to users table if not exists
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'users' 
        AND column_name = 'settings'
    ) THEN
        ALTER TABLE users
        ADD COLUMN settings JSONB DEFAULT '{
            "measurementSystem": "metric",
            "notifications": true,
            "privacyLevel": "private",
            "dailyGoals": {
                "steps": 10000,
                "sleep": 480,
                "water": 2000
            }
        }'::jsonb;
    END IF;
END $$;

================
File: migrations/03_update_leaderboard_policies.sql
================
-- Drop existing select policy for health_metrics
DROP POLICY IF EXISTS "Users can read their own health metrics" ON health_metrics;

-- Create new policy that allows reading public health metrics
CREATE POLICY "Users can read public health metrics"
ON health_metrics
FOR SELECT
USING (
  auth.uid() = user_id OR 
  EXISTS (
    SELECT 1 FROM users 
    WHERE users.id = health_metrics.user_id 
    AND (users.settings->>'privacyLevel')::text = 'public'
  )
);

-- Add composite index for more efficient leaderboard queries
CREATE INDEX IF NOT EXISTS idx_health_metrics_date_score 
ON health_metrics(date, score DESC);

-- Add index for privacy level lookups
CREATE INDEX IF NOT EXISTS idx_users_privacy_level 
ON users((settings->>'privacyLevel'));

-- Add index for combined date range and score queries
CREATE INDEX IF NOT EXISTS idx_health_metrics_date_range_score 
ON health_metrics(date, score DESC) 
WHERE date >= CURRENT_DATE - INTERVAL '7 days';

-- Update get_user_rank function to respect privacy settings
CREATE OR REPLACE FUNCTION get_user_rank(user_uuid UUID, target_date DATE)
RETURNS INTEGER AS $$
DECLARE
    user_rank INTEGER;
    user_privacy_level TEXT;
BEGIN
    -- Get the user's privacy level
    SELECT (settings->>'privacyLevel')::text
    INTO user_privacy_level
    FROM users
    WHERE id = user_uuid;

    -- If user is private, return null
    IF user_privacy_level = 'private' THEN
        RETURN NULL;
    END IF;

    -- Get rank considering only public users and the requesting user
    SELECT rank
    INTO user_rank
    FROM (
        SELECT hm.user_id,
               RANK() OVER (ORDER BY hm.score DESC) as rank
        FROM health_metrics hm
        JOIN users u ON u.id = hm.user_id
        WHERE hm.date = target_date
        AND (
            hm.user_id = user_uuid OR
            (u.settings->>'privacyLevel')::text = 'public'
        )
    ) rankings
    WHERE user_id = user_uuid;
    
    RETURN user_rank;
END;
$$ LANGUAGE plpgsql;

-- Create function to get daily leaderboard with privacy settings
CREATE OR REPLACE FUNCTION get_daily_leaderboard(target_date DATE)
RETURNS TABLE (
    user_id UUID,
    steps INTEGER,
    distance NUMERIC,
    score INTEGER,
    users JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        hm.user_id,
        hm.steps,
        hm.distance,
        hm.score,
        jsonb_build_object(
            'display_name', u.display_name,
            'photo_url', u.photo_url,
            'settings', u.settings
        ) as users
    FROM health_metrics hm
    JOIN users u ON u.id = hm.user_id
    WHERE 
        hm.date = target_date
        AND (
            -- Include only public profiles and the requesting user's data
            (u.settings->>'privacyLevel')::text = 'public'
            OR hm.user_id = auth.uid()
        )
    ORDER BY hm.score DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to get weekly leaderboard with privacy settings
CREATE OR REPLACE FUNCTION get_weekly_leaderboard(start_date DATE, end_date DATE)
RETURNS TABLE (
    user_id UUID,
    steps BIGINT,
    distance NUMERIC,
    score BIGINT,
    users JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        hm.user_id,
        SUM(hm.steps)::BIGINT as steps,
        SUM(hm.distance)::NUMERIC as distance,
        SUM(hm.score)::BIGINT as score,
        jsonb_build_object(
            'display_name', u.display_name,
            'photo_url', u.photo_url,
            'settings', u.settings
        ) as users
    FROM health_metrics hm
    JOIN users u ON u.id = hm.user_id
    WHERE 
        hm.date BETWEEN start_date AND end_date
        AND (
            -- Include only public profiles and the requesting user's data
            (u.settings->>'privacyLevel')::text = 'public'
            OR hm.user_id = auth.uid()
        )
    GROUP BY 
        hm.user_id,
        u.display_name,
        u.photo_url,
        u.settings
    ORDER BY SUM(hm.score) DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function for weekly rankings
CREATE OR REPLACE FUNCTION get_weekly_user_rank(user_uuid UUID, start_date DATE, end_date DATE)
RETURNS INTEGER AS $$
DECLARE
    user_rank INTEGER;
    user_privacy_level TEXT;
BEGIN
    -- Get the user's privacy level
    SELECT (settings->>'privacyLevel')::text
    INTO user_privacy_level
    FROM users
    WHERE id = user_uuid;

    -- If user is private, return null
    IF user_privacy_level = 'private' THEN
        RETURN NULL;
    END IF;

    -- Get rank considering only public users and the requesting user
    SELECT rank
    INTO user_rank
    FROM (
        SELECT 
            hm.user_id,
            RANK() OVER (ORDER BY SUM(hm.score) DESC) as rank
        FROM health_metrics hm
        JOIN users u ON u.id = hm.user_id
        WHERE hm.date BETWEEN start_date AND end_date
        AND (
            hm.user_id = user_uuid OR
            (u.settings->>'privacyLevel')::text = 'public'
        )
        GROUP BY hm.user_id
    ) rankings
    WHERE user_id = user_uuid;
    
    RETURN user_rank;
END;
$$ LANGUAGE plpgsql;

================
File: migrations/04_grant_leaderboard_function_permissions.sql
================
-- Drop existing functions if they exist
DROP FUNCTION IF EXISTS public.get_daily_leaderboard(target_date DATE);
DROP FUNCTION IF EXISTS public.get_weekly_leaderboard(start_date DATE, end_date DATE);
DROP FUNCTION IF EXISTS public.get_user_rank(user_uuid UUID, target_date DATE);
DROP FUNCTION IF EXISTS public.get_weekly_user_rank(user_uuid UUID, start_date DATE, end_date DATE);

-- Recreate the functions in the public schema explicitly with text parameters
CREATE OR REPLACE FUNCTION public.get_daily_leaderboard(target_date text)
RETURNS TABLE (
    user_id UUID,
    steps INTEGER,
    distance NUMERIC,
    score INTEGER,
    users JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        hm.user_id,
        hm.steps,
        hm.distance,
        hm.score,
        jsonb_build_object(
            'display_name', u.display_name,
            'photo_url', u.photo_url,
            'settings', u.settings
        ) as users
    FROM health_metrics hm
    JOIN users u ON u.id = hm.user_id
    WHERE 
        hm.date = target_date::date
        AND (
            -- Include only public profiles and the requesting user's data
            (u.settings->>'privacyLevel')::text = 'public'
            OR hm.user_id = auth.uid()
        )
    ORDER BY hm.score DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.get_weekly_leaderboard(start_date text, end_date text)
RETURNS TABLE (
    user_id UUID,
    steps BIGINT,
    distance NUMERIC,
    score BIGINT,
    users JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        hm.user_id,
        SUM(hm.steps)::BIGINT as steps,
        SUM(hm.distance)::NUMERIC as distance,
        SUM(hm.score)::BIGINT as score,
        jsonb_build_object(
            'display_name', u.display_name,
            'photo_url', u.photo_url,
            'settings', u.settings
        ) as users
    FROM health_metrics hm
    JOIN users u ON u.id = hm.user_id
    WHERE 
        hm.date BETWEEN start_date::date AND end_date::date
        AND (
            -- Include only public profiles and the requesting user's data
            (u.settings->>'privacyLevel')::text = 'public'
            OR hm.user_id = auth.uid()
        )
    GROUP BY 
        hm.user_id,
        u.display_name,
        u.photo_url,
        u.settings
    ORDER BY SUM(hm.score) DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions to authenticated users for leaderboard functions
GRANT EXECUTE ON FUNCTION public.get_daily_leaderboard(text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_weekly_leaderboard(text, text) TO authenticated;

-- Ensure functions are in public schema and owned by postgres
ALTER FUNCTION public.get_daily_leaderboard(text) OWNER TO postgres;
ALTER FUNCTION public.get_weekly_leaderboard(text, text) OWNER TO postgres;

-- Notify PostgREST to reload its schema cache
NOTIFY pgrst, 'reload schema';
